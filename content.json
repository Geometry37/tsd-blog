{"meta":{"title":"Geometry37","subtitle":"","description":"Geometry37 blog, OI, 女装, 信息学, 二次元, 萌新妹子","author":"Geometry37","url":"https://blog.geometry37.tk","root":"/"},"pages":[{"title":"","date":"2021-01-28T02:48:29.664Z","updated":"2021-01-28T02:48:29.664Z","comments":true,"path":"main.css","permalink":"https://blog.geometry37.tk/main.css","excerpt":"","text":"body { background: url(https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2876623392,2931014876&fm=26&gp=0.jpg); background-attachment:fixed; } #name { font-family: 'Courier New', Courier, monospace, cursive; } .header { background: url(https://files.dbnuo.com/wallpaper/menu_bg.gif) no-repeat scroll center center / 100%; }"},{"title":"404 Not Found：该页无法显示","date":"2021-01-13T13:32:27.024Z","updated":"2020-12-09T03:59:04.000Z","comments":false,"path":"/404.html","permalink":"https://blog.geometry37.tk/404.html","excerpt":"","text":""},{"title":"分类","date":"2021-01-28T08:31:01.000Z","updated":"2021-01-28T08:31:23.848Z","comments":false,"path":"c/index.html","permalink":"https://blog.geometry37.tk/c/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-01-27T14:21:55.892Z","updated":"2021-01-27T14:21:55.892Z","comments":true,"path":"links/index.html","permalink":"https://blog.geometry37.tk/links/index.html","excerpt":"","text":"qaq"},{"title":"标签","date":"2021-01-28T08:29:13.000Z","updated":"2021-02-01T01:39:11.390Z","comments":false,"path":"t/index.html","permalink":"https://blog.geometry37.tk/t/index.html","excerpt":"","text":""},{"title":"test","date":"2021-01-28T08:25:38.000Z","updated":"2021-01-28T08:26:57.055Z","comments":true,"path":"test/index.html","permalink":"https://blog.geometry37.tk/test/index.html","excerpt":"","text":"aia_iai​ a_i 10510^5105 10^5"}],"posts":[{"title":"树与二叉树","slug":"树与二叉树","date":"2021-02-01T03:16:37.000Z","updated":"2021-02-01T05:52:41.153Z","comments":true,"path":"p/树与二叉树/","link":"","permalink":"https://blog.geometry37.tk/p/%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"# 树 定义：由 n(n≥30)n(n \\ge 30)n(n≥30) 个节点的有限级。（n=0n=0n=0 时成为空树） 结点的度：子节点的度 结点关系： A 是 BC 的父结点 BC 是 A 的子结点 DEF 是兄弟结点 结点层次： 树的深度：结点的最大层次数 树的宽度：每一层结点个数最大值 # 二叉树 # 特点 每个结点最多 2 个子结点，所以二叉树中结点的度 ≤2\\le 2≤2 每个结点最多 2 个子结点，称为左儿子和右儿子，他们有顺序的，且顺序不能任意颠倒 二叉树第 iii 层最多 2i−12^{i-1}2i−1 个结点 深度为 iii 的二叉树最多 2i−12^i - 12i−1 个结点 # 满二叉树 所有分支节点都有两个子结点 所有叶结点都在同一层上 结点 iii 的左儿子 iii 右儿子 i+1i+1i+1 结点 iii 的父结点 ⌊i2⌋\\left\\lfloor \\dfrac{i}{2} \\right\\rfloor⌊2i​⌋ # 重复二叉树 所有结点位置与满二叉树相同 # 二叉树的存储 123struct node &#123; int left, right, father;&#125; dot[1005]; 或 1left[1005], right[1005], father[1005]; # 二叉树的遍历 结构体： 1234void dfs(int id, int depth) &#123; dfs(dot[i].left, depth + 1); dfs(dot[i].right, depth + 1);&#125; 二维数组： 1void dfs(int id, int fa) 遍历：从根结点出发，按照某种次序访问二叉树中的所有结点，每个结点，有且仅有一次访问 次序：前序遍历，中序遍历，后序遍历 （dfs）层次遍历（bfs） # 前序遍历 dfs 时，第 1 次搜到某个结点就输出 根左右：先搜根 -&gt; 左儿子 -&gt; 右儿子 输出 dfs： 输出 root … 根 dfs（左子树）… 左 dfs（右子树）… 右 # 中序遍历 dfs 时，第 2 次搜到某个结点就输出 左根右：先搜左儿子 -&gt; 根 -&gt; 右儿子 输出 dfs： dfs（左子树）… 左 输出 root … 根 dfs（右子树）… 右 # 后序遍历 dfs 时，第 3 次搜到某个结点就输出 左右根：先搜左儿子 -&gt; 右儿子 -&gt; 根 输出 dfs： dfs（左子树）… 左 dfs（右子树）… 右 输出 root … 根 # 层次遍历 bfs 进行遍历 # 前中定后，中后定前，前后定中 前：ABCDEF 中：CBAEDF 后：CBEFDA # 例题 # [LuoguP1087][NOIP2004 普及组] FBI 树 Link # Solution 看样例： 欲求后序遍历，模板题，套模板即可。 # Code 123456789101112131415161718192021222324252627282930313233343536373839// Problem: P1087 [NOIP2004 普及组] FBI 树// Contest: Luogu// URL: https://www.luogu.com.cn/problem/P1087// Memory Limit: 125 MB// Time Limit: 1000 ms// Powered by CP Editor (https://github.com/cpeditor/cpeditor)#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#define ll long longusing namespace std;int n;string s;void maketree(int x, int y) &#123; if (y &gt; x) &#123; maketree(x, (x + y) / 2); //左 maketree((x + y) / 2 + 1, y); //右 &#125; bool B = true, I = true; for (int i = x; i &lt;= y; i++) &#123; if (s[i] == &#x27;1&#x27;) B = false; else if (s[i] == &#x27;0&#x27;) I = false; &#125; if (B == true) cout &lt;&lt; &quot;B&quot;; else if (I == true) cout &lt;&lt; &quot;I&quot;; else cout &lt;&lt; &quot;F&quot;;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; s; maketree(0, s.size() - 1); puts(&quot;&quot;); return 0;&#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"https://blog.geometry37.tk/c/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://blog.geometry37.tk/t/%E5%9B%BE%E8%AE%BA/"},{"name":"二叉树","slug":"二叉树","permalink":"https://blog.geometry37.tk/t/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"树","slug":"树","permalink":"https://blog.geometry37.tk/t/%E6%A0%91/"}]},{"title":"[AT4763][ABC133B] Good-Distance","slug":"[AT4763][ABC133B]Good-Distance","date":"2021-01-29T07:20:37.000Z","updated":"2021-01-31T14:18:25.143Z","comments":true,"path":"p/at4763/","link":"","permalink":"https://blog.geometry37.tk/p/at4763/","excerpt":"","text":"# solution 看到数据后暴力即可，暴力模拟，算出每个点的距离，然后判断若为整数就记录即可。 # code 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#define int long longusing namespace std;const int NR = 15;int n, d, ans;int x[NR][NR];int sqr(int a) &#123; return a * a;&#125;signed main() &#123; cin &gt;&gt; n &gt;&gt; d; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= d; j++) cin &gt;&gt; x[i][j]; for (int i = 1; i &lt;= n; i++) for (int j = i + 1; j &lt;= n; j++) &#123; double dd = 0; for (int k = 1; k &lt;= d; k++) dd += sqr(x[i][k] - x[j][k]); dd = sqrt(dd); if (dd == (int)dd) ans++; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"AtCoder","slug":"AtCoder","permalink":"https://blog.geometry37.tk/t/AtCoder/"},{"name":"ABC","slug":"ABC","permalink":"https://blog.geometry37.tk/t/ABC/"},{"name":"模拟","slug":"模拟","permalink":"https://blog.geometry37.tk/t/%E6%A8%A1%E6%8B%9F/"}]},{"title":"[AT4110][ABC094B] Toll Gates","slug":"[AT4110][ABC094B]-Toll-Gates","date":"2021-01-28T08:05:51.000Z","updated":"2021-01-28T08:24:30.552Z","comments":true,"path":"p/at4110/","link":"","permalink":"https://blog.geometry37.tk/p/at4110/","excerpt":"","text":"AT4110 # 题意简述 有一个长为 NNN 的路 1,2,3,...,N1,2,3,...,N1,2,3,...,N，路中有 MMM 个收费站，第 iii 个收费站在路的第 aia_iai​ 位置，收费 111 金币，你现在在 XXX 问从 XXX 走到 111 或走到 NNN 的最少花费 # 题目思路 用两个变量 l,rl, rl,r 记录 XXX 左与右的花费，最后一比较大小即可。 # code 123456789101112131415#include &lt;iostream&gt;using namespace std;int n, m, x;int a, l, r;int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; x; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; a; if (a &lt; x) l++; else r++; &#125; if (l &gt; r) cout &lt;&lt; r &lt;&lt; endl; else cout &lt;&lt; l &lt;&lt; endl; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"AtCoder","slug":"AtCoder","permalink":"https://blog.geometry37.tk/t/AtCoder/"},{"name":"ABC","slug":"ABC","permalink":"https://blog.geometry37.tk/t/ABC/"},{"name":"模拟","slug":"模拟","permalink":"https://blog.geometry37.tk/t/%E6%A8%A1%E6%8B%9F/"}]},{"title":"2021洛谷冬日绘版记录","slug":"2021洛谷冬日绘版记录","date":"2021-01-13T12:47:30.000Z","updated":"2021-01-30T07:42:53.033Z","comments":true,"path":"p/2021洛谷冬日绘版记录/","link":"","permalink":"https://blog.geometry37.tk/p/2021%E6%B4%9B%E8%B0%B7%E5%86%AC%E6%97%A5%E7%BB%98%E7%89%88%E8%AE%B0%E5%BD%95/","excerpt":"","text":"# 贡献 Cookie 在此向各位征集 cookie，感谢各位的支持 qaqaq 可以将 cookie 私信 发给我，您需要发两个东西： _uid 及 __client_id 声明：获取了 cookie 即可用该账号使用洛谷上一些其他功能。我承诺不会利用他人账号的 cookie 用作除冬日绘版外的任何用途。并且，这些 cookie 将在活动结束后彻底删除，不会留有记录。 如果您提供了 cookie 即自动默认为已经知晓此声明。 活动过程中如果不幸和谁出现了战争（bushi 可以和我协商 # 冬日绘板实况 # 前序 # 2020-12-30 找到了 ouuan 神仙的 LuoguPaintBoard 并计划画点什么，但又没想好，结果脚本大失败，根本不会弄。 # 2020-12-31 看各位神仙都在征集 cookie，又想着自己啥也不会弄，还不如贡献个 cookie，就把一个 cookie 贡献给了铃酱。 # 2021-01-01 Happy New Year！ 看大家都热火朝天的画，在看到铃酱画好后，自己十分心急，想搞好脚本。 因为没脚本，只能手画，竟然也画了个 Trotyl ，还说要是没被吞 rui_er 就 nz（ 结果没 20m 就没了 下午下定决心，一步一步按照 README 竟然搞好了脚本，用脚本画出了第一个点！ 但是没找到好素材，手上也只有两个 cookie，啥也没画成 晚上，终于决定搞个图片，发了个贴寻求 Cookie，没想到 SSerxhs 神仙想跟我合作弄一个珂朵莉，就决定搞这个，又收集到 8 个 cookie，感觉充满了希望（ 进度很快啊，啪几个点就画好了！可惜还是没有大玩家画的快。 祝愿能保住（ # 实况 [2021-01-01 21:15] 在 (51,201) 开工，大小 80*80 ，希望程序无 bug，不会被人攻击 [2021-01-02 07:00] 早上起来发现已经画好啦！一晚上竟然没遭受攻击，看来选址不错，接下来进入维护期，右边有个 cookie 超多的占了亿点，决定放弃了 /kk 实况：（左 - 红圈处） [2021-01-02 11:47] 看到大家都在画校徽，打算画一个 “北京一零一中” 字样，定在了最下面。 [2021-01-02 13:22] 突然有个帖，说要在那个位置画一个老 K 语录，一看是大玩家，固守阵地肯定打不过，决定换位置，换到了 “北大附中” 上面，整好 @tarjin 提供了 3 个 cookie。 [2021-01-02 14:30] 实况： [2021-01-02 14:55] 跟另一个人发生了冲突，稍微协商了一下，决定将那个珂朵莉的位置让给他，专心画一零一 /kk [2021-01-02 16:08] 字样被 karry 的头像攻击了 /dk/dk 实在比不过，挪到了右边改画校徽 [2021-01-03 上午] 校徽已经画好，我又想整点别的，于是就在 “全世界无产者” 下面画了一只可爱的羊驼，又不甘心校名被吃，于是在雀魂左下画了校名，画好了以后不知道是谁一直随机撒点，于是又一次征集 cookies 反抗，最终压了下去 qaq [2021-01-03 下午] 基本上改画的都画完了，地方也没多少了，于是野心膨胀 ，发现 EA 头像左边的小宇宙被残食了，感觉是块宝地，于是打算在上面画个头像，说干就干，因为此时我的 cookie 数达到了 20+，于是马上画好。 [2021-01-03 17:30] 实况，红圈处为头像 qaq 但是好景不长…… 在仅仅十几分钟后，又被小宇宙吃了回去呜呜呜（ 我又换了好几个地包括下面的小树，东方天空璋等等，但是因为 cookie 数没人加多，都被打了回去呜呜（ 于是开始维护期，再也不瞎画了（ [2021-01-03 22:15] 看着即将远去的 2020，内心感慨万千，在这最后两小时里，打算在留下那么一点东西，于是打算，在舟游下面画上这么一句话，激励自己 我们的征程，是星辰大海！ 在最后半小时，画完了，圆满结束了这次冬日绘版活动。 # 最后 冬日绘版圆满结束，2020 圆满（？） 走去，2021，已经走来，想着距离自己 AFO 的日子越来越近，心中无比的悔恨与伤心。 我能在 OI 界留下些什么呢？ 最后的最后，看一下冬日绘版我所画的最后留下来的所有东西吧 # 新的一年，新的我。2021，你好！","categories":[{"name":"2020","slug":"2020","permalink":"https://blog.geometry37.tk/c/2020/"},{"name":"游记","slug":"2020/游记","permalink":"https://blog.geometry37.tk/c/2020/%E6%B8%B8%E8%AE%B0/"}],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://blog.geometry37.tk/t/%E6%B4%9B%E8%B0%B7/"},{"name":"水","slug":"水","permalink":"https://blog.geometry37.tk/t/%E6%B0%B4/"},{"name":"冬日绘版","slug":"冬日绘版","permalink":"https://blog.geometry37.tk/t/%E5%86%AC%E6%97%A5%E7%BB%98%E7%89%88/"},{"name":"python","slug":"python","permalink":"https://blog.geometry37.tk/t/python/"}]},{"title":"[AT3621][ARC084B] Small Multiple","slug":"[AT3621][ARC084B]Small-Multiple","date":"2021-01-13T12:47:30.000Z","updated":"2021-01-29T07:22:24.713Z","comments":true,"path":"p/at3621/","link":"","permalink":"https://blog.geometry37.tk/p/at3621/","excerpt":"","text":"# solution 我们先考虑暴力，把 KKK 的倍数枚举，每枚举一个取每位求和。 这肯定超时，关键是循环取每位爆炸，那么我们不妨想，一个数的各个位数和是如何求出的。 先看个位，111 的位和为 111，222 就在 111 的前提下 +1+1+1 以此类推，就能求出个位位和。 再看其他位，无非就是 nnn 个 101010 加上若干 111，思考 101010，我们可以用 1×101 \\times 101×10 来表示，那各位和仍为 111。 综上，我们可以整理出两种状态：+1+1+1 与 ×10\\times 10×10，那么 +1+1+1 是各位和 +1+1+1，可 ×10\\times 10×10 各位和却不便，故可以转换为 01 bfs，如图 但是我们发现还有一个问题，那就是这种方法是会超 long long\\sf long~longlong long 的，难道我们还要用高精吗？ 当然不，我们发现我们欲求 KKK 的倍数，那么我们在每次 ×10\\times 10×10 是 %K\\% K%K 就行了，因为这样余数不变，不影响结果。 讲完基本思路，讲一下如何实现。 我们知道 bfs 一般会用队列，那么在 01 bfs 中，我们会用到双向队列 deque\\rm dequedeque。 #include &lt;queue&gt; 与 #include &lt;deque&gt; 均包含 deque\\rm dequedeque，可以用任意一个库。 # Code 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;deque&gt;using namespace std;const int NR = 1e6 + 5;int k;int ans;bool vis[NR];struct node &#123; int num, w;&#125;;deque&lt;node&gt; d;void bfs() &#123; d.push_front(node&#123;1, 1&#125;); vis[1] = true; while (!d.empty()) &#123; int num = d.front().num, w = d.front().w; d.pop_front(); if (num == 0) &#123; cout &lt;&lt; w &lt;&lt; endl; return; &#125; if (!vis[10 * num % k]) &#123; d.push_front(node&#123;10 * num % k, w&#125;); vis[10 * num % k] = true; &#125; if (!vis[num + 1]) &#123; d.push_back(node&#123;num + 1, w + 1&#125;); &#125; &#125; return;&#125;int main() &#123; cin &gt;&gt; k; bfs(); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"AtCoder","slug":"AtCoder","permalink":"https://blog.geometry37.tk/t/AtCoder/"},{"name":"ARC","slug":"ARC","permalink":"https://blog.geometry37.tk/t/ARC/"},{"name":"广度优先搜索,BFS","slug":"广度优先搜索-BFS","permalink":"https://blog.geometry37.tk/t/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-BFS/"},{"name":"图论","slug":"图论","permalink":"https://blog.geometry37.tk/t/%E5%9B%BE%E8%AE%BA/"}]},{"title":"[AT3931][ABC089B] Hina Arare","slug":"[AT3931][ABC089B]Hina-Arare","date":"2021-01-13T12:47:30.000Z","updated":"2021-01-30T07:08:45.297Z","comments":true,"path":"p/at3931/","link":"","permalink":"https://blog.geometry37.tk/p/at3931/","excerpt":"","text":"# solution 简单模拟。 法一 我们定义 4 个变量 p,w,g,yp,w,g,yp,w,g,y ，要是出现了就赋值为 1，最后一加就是个数。 法二 定义 4 个变量 p,w,g,yp,w,g,yp,w,g,y 分别记录 P,W,G,Y 是否出现过，若未出现则 ans+1ans+1ans+1 并标记为出现过。 # code 法一 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#define ll long longusing namespace std;int n, p, w, g, y;int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; char c; cin &gt;&gt; c; if (c == &#x27;P&#x27;) p = 1; if (c == &#x27;W&#x27;) w = 1; if (c == &#x27;G&#x27;) g = 1; if (c == &#x27;Y&#x27;) y = 1; &#125; if (p + w + g + y == 3) cout &lt;&lt; &quot;Three&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Four&quot; &lt;&lt; endl; return 0;&#125; 法二 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#define ll long longusing namespace std;int n;bool p, w, g, y;int main() &#123; cin &gt;&gt; n; int ans = 0; for (int i = 1; i &lt;= n; i++) &#123; char c; cin &gt;&gt; c; if (c == &#x27;P&#x27; &amp;&amp; !p) ans++, p = true; if (c == &#x27;W&#x27; &amp;&amp; !w) ans++, w = true; if (c == &#x27;G&#x27; &amp;&amp; !g) ans++, g = true; if (c == &#x27;Y&#x27; &amp;&amp; !y) ans++, y = true; &#125; if (ans == 3) cout &lt;&lt; &quot;Three&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Four&quot; &lt;&lt; endl; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"AtCoder","slug":"AtCoder","permalink":"https://blog.geometry37.tk/t/AtCoder/"},{"name":"ABC","slug":"ABC","permalink":"https://blog.geometry37.tk/t/ABC/"},{"name":"模拟","slug":"模拟","permalink":"https://blog.geometry37.tk/t/%E6%A8%A1%E6%8B%9F/"},{"name":"字符串","slug":"字符串","permalink":"https://blog.geometry37.tk/t/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"[AT5037]Consecutive Integers","slug":"[AT5037]Consecutive-Integers","date":"2020-12-27T01:40:51.000Z","updated":"2021-01-31T14:19:46.422Z","comments":true,"path":"p/at5037/","link":"","permalink":"https://blog.geometry37.tk/p/at5037/","excerpt":"","text":"# 题目大意 有从 111 到 nnn 共 nnn 个数，求连续整数长度为 kkk 的个数。 # 解题思路 让我们来认认真真推下柿子 假设 n=3,k=2n = 3, k = 2n=3,k=2，那么很容易求出值为 222，但这是怎么求出的？ 不妨列一下： 1231\\quad2\\quad3123 那么我们可以选取 1‾2‾3\\underline{1}\\quad\\underline2\\quad31​2​3 与 12‾3‾1\\quad\\underline2\\quad\\underline312​3​ 我们发现可以通过枚举开头的可行位置，然后往后推 kkk 位则必然符合，开头的可行位置个数即所求，但是因为需往后推 kkk 位，所以开头可行位置就要 −k-k−k，且我们发现，从开头 111 已占一位，故此时可行数又要 +1+1+1。 综上，我们推出了此题的式子：n−k−1n - k - 1n−k−1，那么这题就迎刃而解了。 # code 12345678910111213141516#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#define ll long longusing namespace std;int n, k;int main() &#123; cin &gt;&gt; n &gt;&gt; k; cout &lt;&lt; n - k + 1 &lt;&lt; endl; return 0;&#125; # record Link","categories":[{"name":"题解","slug":"题解","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"数论,数学","slug":"数论-数学","permalink":"https://blog.geometry37.tk/t/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"}]},{"title":"NOI 系列题解总集","slug":"NOI-系列题解总集","date":"2020-12-25T13:58:43.000Z","updated":"2021-01-13T12:59:44.353Z","comments":true,"path":"p/NOI系列题解总集/","link":"","permalink":"https://blog.geometry37.tk/p/NOI%E7%B3%BB%E5%88%97%E9%A2%98%E8%A7%A3%E6%80%BB%E9%9B%86/","excerpt":"","text":"每次做一道 NOI 系列的估计都很激动吧，对于我这种萌新来说（ # P1731 [NOI1999] 生日蛋糕 练习剪枝技巧，关于剪枝，欢迎看我的垃圾无意义笔记 这道题是有一定难度的，需要运用各种高科技剪枝（？ 如果泥能独立 AC 这道题，就可以拿到 NOI 铜牌了！ （不过是 1999 年的，现在肯定难多了 其实这道题根本不需要考虑 π\\piπ 因为： V圆柱=S圆柱×h=πr2×hN=r2×h\\begin{aligned} V_{\\text{圆柱}} &amp; = S_{\\text{圆柱}} \\times h\\\\ &amp;= \\pi r^2\\times h\\\\ N &amp; = r^2\\times h \\end{aligned}V圆柱​N​=S圆柱​×h=πr2×h=r2×h​ S圆柱侧=2πr×hS=2rhS=2Nr\\begin{aligned} S_{\\text{圆柱侧}} &amp; = 2\\pi r \\times h\\\\ S &amp;= 2rh\\\\ S &amp;= \\frac{2N}{r} \\end{aligned}S圆柱侧​SS​=2πr×h=2rh=r2N​​ 因为为了方便，搜索的参数为 555 个： \\text \\text 体积为 100100100 的栗子：画张图，更好理解： 去搜每一层蛋糕的半径和高度。因为是整数，所以把所有的半径和高度枚举一遍， rrr 的根节点从 101010 开始。从最大值到最小值，如果体积明显超出了，就可以剪枝。 枚举第一层蛋糕的高度。 此时的时间复杂度是 O(n2)O(n^2)O(n2) 因为比较暴力，所以必须用到各种剪枝，在 O(n2)O(n^2)O(n2) 的基础上进行剪枝 可行性剪枝 最优化剪枝 上下界剪枝 搜索顺序剪枝 半径从大到小，从小到大。 高度从大到小，从小到大。 共 4 种搜索顺序，找到最快的顺序。 最终就能 AC 本题啦～ 放上 dfsdfsdfs 代码，有注释应该很好理解吧 /kk： 1234567891011121314151617void dfs(int ceng, int restv, int r, int h, int s) &#123;//ceng为已用层数，restv为剩余体积，r为当前最高层蛋糕半径，h为当前最高层蛋糕高度，s为已有表面积/π if(ceng == m &amp;&amp; restv == 0) //蛋糕已完成，即层数ceng==m且体积用完 &#123; ans = min(ans, s); //更新答案为最优解 return; &#125; if(restv &lt; 0) return; //剩余体积小于0表示体积超过了预定的值 if(s + 2 * restv / r &gt;= ans) return; //若当前总表面积+该层往上所有表面积的最小和&gt;=目前最优解 //简单一点可以把每一层的侧面积看做最小的1，那么后续剩下部分的侧面积就等于剩余层数m-ceng //数据严格一点就可以从剩余体积去计算出剩余最小侧面积2 * restv / r,可改为if(s + 2 * restv / r &gt;= ans) if(r * r * h * (m - ceng) &lt; restv) return; //后续能做出蛋糕的最大体积&lt;当前剩余体积 for(int i = r - 1; i &gt;= m - ceng; i--) //枚举下一层所有可能的半径 for(int j = h - 1; j &gt;= m - ceng; j--) //枚举下一层所有可能的高度 if(ceng != 0) dfs(ceng + 1, restv - i * i * j, i, j, s + 2 * i * j); else dfs(ceng + 1, restv - i * i * j, i, j, s + 2 * i * j + i * i); //第一层需要计算上表面积，其他层只需计算侧面积即可，故需分类讨论&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/"},{"name":"总集","slug":"题解/总集","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/%E6%80%BB%E9%9B%86/"}],"tags":[{"name":"深度优先搜索,DFS","slug":"深度优先搜索-DFS","permalink":"https://blog.geometry37.tk/t/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-DFS/"},{"name":"剪枝","slug":"剪枝","permalink":"https://blog.geometry37.tk/t/%E5%89%AA%E6%9E%9D/"},{"name":"NOI","slug":"NOI","permalink":"https://blog.geometry37.tk/t/NOI/"}]},{"title":"[SP867] CUBES - Perfect Cubes","slug":"[SP867]-CUBES-Perfect-Cubes","date":"2020-12-25T13:57:32.000Z","updated":"2021-01-13T12:59:00.628Z","comments":true,"path":"p/sp867/","link":"","permalink":"https://blog.geometry37.tk/p/sp867/","excerpt":"","text":"这道题明显是一道暴力。 暴力枚举每一个 a,b,c,da, b, c, da,b,c,d 所以我就写了一个暴力。每个 a,b,c,da, b, c, da,b,c,d 都从 111 枚举到 100100100 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define line cout &lt;&lt; endlusing namespace std;int lf(int x) &#123; return x * x * x;&#125;int main() &#123; for (int a = 1; a &lt;= 100; a++) &#123; for (int b = 1; b &lt;= 100; b++) &#123; for (int c = 1; c &lt;= 100; c++) &#123; for (int d = 1; d &lt;= 100; d++) &#123; if (lf(a) == lf(b) + lf(c) + lf(d)) &#123; cout &lt;&lt; &quot;Cube = &quot; &lt;&lt; a &lt;&lt; &quot;, Triple = (&quot; &lt;&lt; b &lt;&lt; &quot;,&quot; &lt;&lt; c &lt;&lt; &quot;,&quot; &lt;&lt; d &lt;&lt; &quot;)&quot;; line; &#125; &#125; &#125; &#125; &#125; return 0;&#125; 结果，成功的 WA 掉了（（（ 为什么？ 我们仔细观察题目给出的前几个样例： 1234567Cube = 6, Triple = (3,4,5)Cube = 12, Triple = (6,8,10)Cube = 18, Triple = (2,12,16)Cube = 18, Triple = (9,12,15)Cube = 19, Triple = (3,10,18)Cube = 20, Triple = (7,14,17)Cube = 24, Triple = (12,16,20) 而再看上面的程序输出的前几个： 123456789101112Cube = 6, Triple = (3,4,5)Cube = 6, Triple = (3,5,4)Cube = 6, Triple = (4,3,5)Cube = 6, Triple = (4,5,3)Cube = 6, Triple = (5,3,4)Cube = 6, Triple = (5,4,3)Cube = 9, Triple = (1,6,8)Cube = 9, Triple = (1,8,6)Cube = 9, Triple = (6,1,8)Cube = 9, Triple = (6,8,1)Cube = 9, Triple = (8,1,6)Cube = 9, Triple = (8,6,1) 发现什么问题了吗？ 相信 全谷最聪明的你 已经发现了问题。 仔细观察 Cube = 6 的情况： 我的程序： 123456Cube = 6, Triple = (3,4,5)Cube = 6, Triple = (3,5,4)Cube = 6, Triple = (4,3,5)Cube = 6, Triple = (4,5,3)Cube = 6, Triple = (5,3,4)Cube = 6, Triple = (5,4,3) 正确答案： 1Cube = 6, Triple = (3,4,5) 有可能题目没有翻译清晰 发现每个 Cube 只需要输出一组，那么我们就可以改变一下循环的初始状态。 将 a,ba,ba,b 从 222 到 100100100 枚举，将 ccc 从 bbb 到 100100100 枚举，将 ddd 从 ccc 到 100100100 枚举。 最后放上代码： 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define line cout &lt;&lt; endlusing namespace std;int lf(int x) &#123;//立方的函数 return x * x * x;&#125;int main() &#123;// freopen(&quot;1.out&quot;, &quot;w&quot;, stdout); for (int a = 2; a &lt;= 100; a++) &#123; for (int b = 2; b &lt;= 100; b++) &#123; for (int c = b; c &lt;= 100; c++) &#123; for (int d = c; d &lt;= 100; d++) &#123; if (lf(a) == lf(b) + lf(c) + lf(d)) &#123; cout &lt;&lt; &quot;Cube = &quot; &lt;&lt; a &lt;&lt; &quot;, Triple = (&quot; &lt;&lt; b &lt;&lt; &quot;,&quot; &lt;&lt; c &lt;&lt; &quot;,&quot; &lt;&lt; d &lt;&lt; &quot;)&quot;; line; &#125; &#125; &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/"},{"name":"SPOJ","slug":"题解/SPOJ","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/SPOJ/"}],"tags":[{"name":"枚举,暴力","slug":"枚举-暴力","permalink":"https://blog.geometry37.tk/t/%E6%9E%9A%E4%B8%BE-%E6%9A%B4%E5%8A%9B/"}]},{"title":"[SP34013]SEUG - Seetha’s Unique Game","slug":"[SP34013]SEUG-Seetha’s-Unique-Game","date":"2020-12-25T13:55:58.000Z","updated":"2021-01-13T12:59:03.184Z","comments":true,"path":"p/sp34013/","link":"","permalink":"https://blog.geometry37.tk/p/sp34013/","excerpt":"","text":"这道题一看就是 贪心 。 使放的石头少，就需要石头大。 那么就可以将石头重量排序，从大到小。 这道题里面看似东西很多，但是很多东西都是没有用的。比如说：箱子的长和宽，因为题目中说「每加一个石头，水的高度就会增加那个石头的重量那么多。」，根本没有用到长和宽，只需要高度。 其次，添加的石头的总重量要 大于 （不是大于等于）长方体剩下的高度。所以只需要循环每次添加最重的石头，当：剩下的高度大于石头总重量时，停止循环，输出石头数量。 详细的，看代码： 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define line cout &lt;&lt; endlusing namespace std;int t;bool cmp(int x, int y) &#123; return x &gt; y;&#125;int main() &#123; cin &gt;&gt; t; for (int T = 1; T &lt;= t; T++) &#123;//T组数据 int a, b, c, d;//分别表示：箱子的长宽高和箱子里有多高的水 cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; int n; cin &gt;&gt; n; int w[n + 5]; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; w[i]; &#125; sort(w + 1, w + n + 1, cmp);//把石头的重量从大到小排序 int ans = 0, cnt = 0;//分别表示：用了的石头的数量，和 while (c - d &gt;= cnt) &#123;//当剩下的高度还小于等于石头的总重量时，进入循环 ans++;//用了的石头的数量加一 cnt += w[ans];//其实这里的ans就是代表用到了第几块石头，不用再建变量，浪费空间（其实是懒得再建变量了（（（ &#125; cout &lt;&lt; ans;//输出答案 line;//换行!!! //换行!!! //换行!!! //重要的事情说三遍（ &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/"},{"name":"SPOJ","slug":"题解/SPOJ","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/SPOJ/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://blog.geometry37.tk/t/%E6%A8%A1%E6%8B%9F/"},{"name":"贪心","slug":"贪心","permalink":"https://blog.geometry37.tk/t/%E8%B4%AA%E5%BF%83/"}]},{"title":"[UVA1149]装箱 Bin Packing","slug":"[UVA1149]装箱-Bin-Packing","date":"2020-12-25T13:55:03.000Z","updated":"2021-01-13T12:59:12.544Z","comments":true,"path":"p/uva1149/","link":"","permalink":"https://blog.geometry37.tk/p/uva1149/","excerpt":"","text":"做法显然：贪心，但是怎么贪？ 首先从大到小或从小到大排序，窝这次是从大到小排，这样更容易理解（从小到大更方变） 然后设置两个变量 front 和 after 作为前指针和后指针。 循环判断： 当前后两个数能放入背包时，则 ans++ 并把两指针： 1 front++; after–; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 - 当不能同时放入时，放进大的那个，也就是前面的那个，并且 &#96;ans++, front++;&#96; 最后看一下code：&#96;&#96;&#96;cpp#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int NR &#x3D; 1e5 + 5;int t, n, m, v[NR], front, after, ans;bool cmp(int x, int y)&#123; return x &gt; y;&#125;void Initialization()&#x2F;&#x2F;每组数据前后初始化&#123; memset(v, 0, sizeof(v));&#x2F;&#x2F;清零 n &#x3D; 0; m &#x3D; 0; front &#x3D; 1; after &#x3D; 0; ans &#x3D; 0;&#125;void Cin()&#x2F;&#x2F;每组数据的输入&#123; cin &gt;&gt; n &gt;&gt; m; for (int i &#x3D; 1; i &lt;&#x3D; n; i++) cin &gt;&gt; v[i]; after &#x3D; n;&#125;int main()&#123; cin &gt;&gt; t; Initialization();&#x2F;&#x2F;初始化 for (int T &#x3D; 1; T &lt;&#x3D; t; T++) &#123; Cin();&#x2F;&#x2F;输入 sort(v + 1, v + n + 1, cmp);&#x2F;&#x2F;排序 for (int i &#x3D; 1; i &lt;&#x3D; n; i++)&#x2F;&#x2F;循环n次，因为最多分配n次，不会超过n次 if (front &gt;&#x3D; after)&#x2F;&#x2F;如果前指针已经超过或等于后指针时说明已经结束,所以结束循环 &#123; ans++; cout &lt;&lt; ans &lt;&lt; endl;&#x2F;&#x2F;输出答案 Initialization();&#x2F;&#x2F;初始化 break; &#125; else if (v[front] + v[after] &lt;&#x3D; m) &#123;&#x2F;&#x2F;如果前后两个物品能放下 ans++; front++;&#x2F;&#x2F;前指针向后移 after--;&#x2F;&#x2F;后指针向前移 &#125; else &#123;&#x2F;&#x2F;否则的话 ans++; front++;&#x2F;&#x2F;只有前指针向后移 &#125; &#125; return 0;&#125; 求赞ฅʕ・̫͡・ʔฅ","categories":[{"name":"题解","slug":"题解","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/"},{"name":"UVA","slug":"题解/UVA","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/UVA/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://blog.geometry37.tk/t/%E6%A8%A1%E6%8B%9F/"},{"name":"贪心","slug":"贪心","permalink":"https://blog.geometry37.tk/t/%E8%B4%AA%E5%BF%83/"}]},{"title":"[CF1182B]Plus from Picture","slug":"[CF1182B]Plus-from-Picture","date":"2020-12-25T13:53:40.000Z","updated":"2021-01-31T14:19:31.122Z","comments":true,"path":"p/cf1182b/","link":"","permalink":"https://blog.geometry37.tk/p/cf1182b/","excerpt":"","text":"这是一道超级水的模拟 + 简单搜索。 说说思路： 先找到中心点，就是自己和上下左右都为 * 的。 上下左右上的所有 * 都删掉，然后再看看有没有多余的 * 如果有输出 NO 否则输出 YES 。 比如说有这样一个 n=5n = 5n=5 的图： ....∗..∗...∗∗∗∗..∗....∗..\\begin{matrix} .&amp;.&amp;.&amp;.&amp;*\\\\ .&amp;.&amp;*&amp;.&amp;.\\\\ .&amp;*&amp;*&amp;*&amp;*\\\\ .&amp;.&amp;*&amp;.&amp;.\\\\ .&amp;.&amp;*&amp;.&amp;. \\end{matrix}.....​..∗..​.∗∗∗∗​..∗..​∗.∗..​ 首先一个一个找，当找到一个点，自己本身和上下左右均为 ∗*∗ 时（如图中 aaa 点）： ....∗..∗...∗a∗∗..∗....∗..\\begin{matrix} .&amp;.&amp;.&amp;.&amp;*\\\\ .&amp;.&amp;*&amp;.&amp;.\\\\ .&amp;*&amp;a&amp;*&amp;*\\\\ .&amp;.&amp;*&amp;.&amp;.\\\\ .&amp;.&amp;*&amp;.&amp;. \\end{matrix}.....​..∗..​.∗a∗∗​..∗..​∗.∗..​ 将上下左右上的一条全部变为 ∗*∗： ....∗....................\\begin{matrix} .&amp;.&amp;.&amp;.&amp;*\\\\ .&amp;.&amp;.&amp;.&amp;.\\\\ .&amp;.&amp;.&amp;.&amp;.\\\\ .&amp;.&amp;.&amp;.&amp;.\\\\ .&amp;.&amp;.&amp;.&amp;. \\end{matrix}.....​.....​.....​.....​∗....​ 那我们就会发现图中还有 ∗*∗ 没有变成 ... 这就说明此加号不合法。 上代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/* Problem:CF1182B Date:14/06/20 12:02*/#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define line cout &lt;&lt; endl#define int long long using namespace std;char ma[2005][2005];int h, w;bool flag;void up (int i, int j) &#123; ma[i][j] = &#x27;.&#x27;; if (ma[i - 1][j] == &#x27;*&#x27;) return up(i - 1, j);&#125;void down (int i, int j) &#123; ma[i][j] = &#x27;.&#x27;; if (ma[i + 1][j] == &#x27;*&#x27;) return down(i + 1, j);&#125;void left (int i, int j) &#123; ma[i][j] = &#x27;.&#x27;; if (ma[i][j - 1] == &#x27;*&#x27;) left(i, j - 1);&#125;void right (int i, int j) &#123; ma[i][j] = &#x27;.&#x27;; if (ma[i][j + 1] == &#x27;*&#x27;) return right(i, j + 1);&#125;void kill (int i, int j) &#123; ma[i][j] = &#x27;.&#x27;; up (i - 1, j); down (i + 1, j); left (i, j - 1); right (i, j + 1);&#125;void test () &#123;//测试(i,j)是不是一个加号的中心 for (int i = 1; i &lt;= h; i++) &#123; for (int j = 1; j &lt;= w; j++) if (ma[i][j] == &#x27;*&#x27; &amp;&amp; ma[i - 1][j] == &#x27;*&#x27; &amp;&amp; ma[i][j - 1] == &#x27;*&#x27; &amp;&amp; ma[i + 1][j] == &#x27;*&#x27; &amp;&amp; ma[i][j + 1] == &#x27;*&#x27;) &#123;//对第一个可能的十字的中心 kill (i, j);//抹去这个十字 flag = true; break; &#125; if (flag) break; &#125; for (int i = 1; i &lt;= h; i++)//这时,应没有&#x27;*&#x27;了 for (int j = 1; j &lt;= w; j++) if (ma[i][j] == &#x27;*&#x27;) flag = false;&#125;signed main () &#123; cin &gt;&gt; h &gt;&gt; w; for(int i = 1; i &lt;= h; i++) for(int j = 1; j &lt;= w; j++) cin &gt;&gt; ma[i][j]; test(); if(flag) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); return 0;&#125;谢谢。","categories":[{"name":"题解","slug":"题解","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/"},{"name":"CodeForces","slug":"题解/CodeForces","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/CodeForces/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://blog.geometry37.tk/t/%E6%A8%A1%E6%8B%9F/"},{"name":"搜索","slug":"搜索","permalink":"https://blog.geometry37.tk/t/%E6%90%9C%E7%B4%A2/"}]},{"title":"深搜——简单剪枝","slug":"深搜——简单剪枝","date":"2020-12-25T13:52:31.000Z","updated":"2021-01-13T12:59:35.723Z","comments":true,"path":"p/深搜-简单剪枝/","link":"","permalink":"https://blog.geometry37.tk/p/%E6%B7%B1%E6%90%9C-%E7%AE%80%E5%8D%95%E5%89%AA%E6%9E%9D/","excerpt":"","text":"# 深搜 —— 简单剪枝 # 说在最前面： 因为马上要 NOIP2020 了，所以菜鸡开始了复习 qwq。 pj 组 T1 ，T2 肯定要拿到满分的，然后 T3 ， T4 拿部分分， T3 拿部分分最常见的做法就是暴搜，但是暴搜容易 T ，为了拿到更多的分数，应该合理剪枝。 # 各种剪枝方法 优化搜索顺序 （随缘）随缘剪枝。 可行性剪枝 对当前状态进行检查，发现分支无法到达递归边界，回溯。 最优化剪枝 ☆☆☆ ← 最重要的一种剪枝方法 在最优化问题的搜索过程中，若当前花费的代价已超过前面搜到的最优解，回溯。 上下界剪枝 按题意，找子节点的上下界。 # 例题 # 例一：洛谷 P1135 奇怪的电梯 Link\\rm\\Large LinkLink 这道题当然 bfs 效率是最快的，但是为了练习剪枝，就可以拿 dfs 做。 思路很简单，从起点开始，只要没越界就向上下搜，全部搜完得到答案。 很容易就得到了代码： 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define line cout &lt;&lt; endlusing namespace std;const int NR = 205;int n, a, b;int k[NR];int ans = 1e9;bool flag[NR];void dfs(int x, int step) &#123; if (x &lt; 1 || x &gt; n || flag[x]) &#123; return; &#125; if (x == b) &#123; if (step &lt; ans) ans = step; return; &#125; flag[x] = true; dfs(x + k[x], step + 1); dfs(x - k[x], step + 1); flag[x] = false;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; a &gt;&gt; b; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; k[i]; &#125; dfs(a, 0); if (ans == 1e9) cout &lt;&lt; &quot;-1&quot;; else cout &lt;&lt; ans; return 0;&#125; 很好，发现得分 80pts80pts80pts 。有两个点 T 了。 所以我们就需要剪枝。 怎么剪枝？ 我们要球的是最优解，所以就可以用 最优剪枝 ，如果当前的 stepstepstep 已经超过了最优解 ansansans ，那么就可以结束了，这样就剪枝成功，最后放上 dfsdfsdfs 代码： 12345678910111213void dfs(int x, int step) &#123; if (x &lt; 1 || x &gt; n || flag[x] || step &gt;= ans) &#123; return; &#125; if (x == b) &#123; if (step &lt; ans) ans = step; return; &#125; flag[x] = true; dfs(x + k[x], step + 1); dfs(x - k[x], step + 1); flag[x] = false;&#125; 当然了，这题如果拿 bfsbfsbfs 做肯定是不会 T 的，但是为了练习剪枝嘛～qwq # 例二：洛谷 P1731 [NOI1999] 生日蛋糕 Link\\rm\\Large LinkLink 这道题是有一定难度的，需要运用各种高科技剪枝（？ 如果泥能独立 AC 这道题，就可以拿到 NOI 铜牌了！ （不过是 1999 年的，现在肯定难多了 其实这道题根本不需要考虑 π\\piπ 因为： V圆柱=S圆柱×h=πr2×hN=r2×h\\begin{aligned} V_{\\text{圆柱}} &amp; = S_{\\text{圆柱}} \\times h\\\\ &amp;= \\pi r^2\\times h\\\\ N &amp; = r^2\\times h \\end{aligned}V圆柱​N​=S圆柱​×h=πr2×h=r2×h​ S圆柱侧=2πr×hS=2rhS=2Nr\\begin{aligned} S_{\\text{圆柱侧}} &amp; = 2\\pi r \\times h\\\\ S &amp;= 2rh\\\\ S &amp;= \\frac{2N}{r} \\end{aligned}S圆柱侧​SS​=2πr×h=2rh=r2N​​ 因为为了方便，搜索的参数为 555 个： \\text \\text 体积为 100100100 的栗子：画张图，更好理解： 去搜每一层蛋糕的半径和高度。因为是整数，所以把所有的半径和高度枚举一遍， rrr 的根节点从 101010 开始。从最大值到最小值，如果体积明显超出了，就可以剪枝。 枚举第一层蛋糕的高度。 此时的时间复杂度是 O(n2)O(n^2)O(n2) 因为比较暴力，所以必须用到各种剪枝，在 O(n2)O(n^2)O(n2) 的基础上进行剪枝 可行性剪枝 最优化剪枝 上下界剪枝 搜索顺序剪枝 半径从大到小，从小到大。 高度从大到小，从小到大。 共 4 种搜索顺序，找到最快的顺序。 最终就能 AC 本题啦～ 放上 dfsdfsdfs 代码，有注释应该很好理解吧 /kk： 1234567891011121314151617void dfs(int ceng, int restv, int r, int h, int s) &#123;//ceng为已用层数，restv为剩余体积，r为当前最高层蛋糕半径，h为当前最高层蛋糕高度，s为已有表面积/π if(ceng == m &amp;&amp; restv == 0) //蛋糕已完成，即层数ceng==m且体积用完 &#123; ans = min(ans, s); //更新答案为最优解 return; &#125; if(restv &lt; 0) return; //剩余体积小于0表示体积超过了预定的值 if(s + 2 * restv / r &gt;= ans) return; //若当前总表面积+该层往上所有表面积的最小和&gt;=目前最优解 //简单一点可以把每一层的侧面积看做最小的1，那么后续剩下部分的侧面积就等于剩余层数m-ceng //数据严格一点就可以从剩余体积去计算出剩余最小侧面积2 * restv / r,可改为if(s + 2 * restv / r &gt;= ans) if(r * r * h * (m - ceng) &lt; restv) return; //后续能做出蛋糕的最大体积&lt;当前剩余体积 for(int i = r - 1; i &gt;= m - ceng; i--) //枚举下一层所有可能的半径 for(int j = h - 1; j &gt;= m - ceng; j--) //枚举下一层所有可能的高度 if(ceng != 0) dfs(ceng + 1, restv - i * i * j, i, j, s + 2 * i * j); else dfs(ceng + 1, restv - i * i * j, i, j, s + 2 * i * j + i * i); //第一层需要计算上表面积，其他层只需计算侧面积即可，故需分类讨论&#125; 好啦！窝拿到 NOI 铜牌啦啊！（雾","categories":[{"name":"笔记","slug":"笔记","permalink":"https://blog.geometry37.tk/c/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"https://blog.geometry37.tk/t/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"https://blog.geometry37.tk/t/DFS/"}]},{"title":"深搜——拿部分分","slug":"深搜——拿部分分","date":"2020-12-25T13:51:18.000Z","updated":"2021-01-13T12:59:37.537Z","comments":true,"path":"p/深搜-拿部分分/","link":"","permalink":"https://blog.geometry37.tk/p/%E6%B7%B1%E6%90%9C-%E6%8B%BF%E9%83%A8%E5%88%86%E5%88%86/","excerpt":"","text":"# 说在最前面 众所周知， NOIP pj 的第三题大部分都是 dp ，但是有可能在考场上想不到动态转移方程，所以我们就可以拿深搜骗分。 # 方法 深搜拿部分分 剪枝 记忆化 看数据范围 有时候发现，写完深搜，发现可以打表 qwq！ 那不就很香嘛（ # 实践出真知 # 例一：P1057 传球游戏 Link\\Large\\rm LinkLink # 法 1 dfs 暴搜 期望得分：40pts\\rm 40pts40pts 首先写出 dfsdfsdfs 的参数： 首先是小蛮在第几号，当然是 111 ，然后是次数 000 再看递归边界 这里是环状递归边界： 123456if (x == 0) x = n;if (x == n + 1) x = 1;if (step == m) &#123; if (x == 1) return 1; return 0;&#125; 接下来往下继续搜。 1dfs(x + 1, step + 1) + dfs(x - 1, step + 1); 好！ 40pts\\rm 40pts40pts 到手！ 那么我们可以再看一下数据范围，那么小！直接打表啊！ 因为时间关系，这里打表就不多讲解了。 # 法 2 加上记忆化 期望得分：90pts\\rm 90pts90pts 大家应该都知道：暴搜加上记忆化 ≈≈≈ 动归 所以我们加上记忆化： 定义一个 aaa 数组，表示在某一个位置经过 stepstepstep 步能否回到起始位置的方法数。 1if (a[x][step] != 0) return a[x][step]; 放上 dfs 代码： 123456789int dfs (int x, int step) &#123; if (x == 0) x = n; if (x == n + 1) x = 1; if (step == m) &#123; if (x == 1) return 1; return 0; &#125; return dfs(x + 1, step + 1) + dfs(x - 1, step + 1);&#125; 为什么是 90 分？？？ 因为想一下，如果是奇数，那么永远传不到小蛮手中，就会肯定 T 。 # 法 3 加一个特判。 期望得分： 100pts100pts100pts 1234 if (n % 2 == 0 &amp;&amp; m % 2 == 1) &#123; cout &lt;&lt; 0; return 0;&#125; # 法 4 既然这题的正解是 dp，那么我们还是要讲讲 dp 的。 其实 dp 和记忆化没有很大的区别。 状态表示：f[i][j]\\rm f[i][j]f[i][j] 表示第 iii 次传球后球在第 jjj 个小朋友手上回到小蛮手中的方案数。 我们发现 f[i][j]\\rm f[i][j]f[i][j] 跟 a[x][step]\\rm a[x][step]a[x][step] 是很像的。 状态转移：\\rm f[i][j] = \\begin{cases} \\rm f[i - 1][j - 1] & \\text{第 i 次传球从左边传给 j}\\\\ \\rm f[i - 1][j + 1] & \\text{第 i 次传球从右边传给 j} \\end 这样写对不对？不对！ 因为这是环状的，环状的解决方法通常是 mod n\\mod nmodn (x+n−1)mod n+1(x + n - 1) \\mod n + 1(x+n−1)modn+1 所以正确状态转移为：\\rm f[i][j] = \\begin{cases} \\rm f[i - 1][(j - 1 + n - 1) \\mod n + 1] & \\text{第 i 次传球从左边传给 j}\\\\ \\rm f[i - 1][(j + 1 + n - 1) \\mod n + 1] & \\text{第 i 次传球从右边传给 j} \\end 所以：f[i][j]=f[i−1][(j−1+n−1)mod n+1]+f[i−1][(j+1+n−1)mod n+1]\\rm f[i][j] = f[i - 1][(j - 1 + n - 1) \\mod n + 1] + f[i - 1][(j + 1 + n - 1) \\mod n + 1]f[i][j]=f[i−1][(j−1+n−1)modn+1]+f[i−1][(j+1+n−1)modn+1] 做完，最后放上 AC 代码： 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define line cout &lt;&lt; endlusing namespace std;int f[35][35];int n, m;int main() &#123; cin &gt;&gt; n &gt;&gt; m; f[1][n] = f[1][2] = 1; for (int i = 2; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; f[i][j] = f[i - 1][(j - 1 + n - 1) % n + 1] + f[i - 1][(j + 1 + n - 1) % n + 1]; &#125; &#125; cout &lt;&lt; f[m][1] &lt;&lt; endl; return 0;&#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"https://blog.geometry37.tk/c/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"深度优先搜索,DFS","slug":"深度优先搜索-DFS","permalink":"https://blog.geometry37.tk/t/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-DFS/"}]},{"title":"[CF1373B]01 Game","slug":"[CF1373B]01-Game","date":"2020-12-25T13:50:25.000Z","updated":"2021-01-31T14:19:26.830Z","comments":true,"path":"p/cf1373b/","link":"","permalink":"https://blog.geometry37.tk/p/cf1373b/","excerpt":"","text":"这题好水，就是简单的模拟 + 字符串。 # Translation\\sf TranslationTranslation 给定一个 010101 串，如果 000 出现的次数和 111 出现的次数的最小值是奇数，输出 DA ，否则输出 NET 多测。 # Solution\\sf SolutionSolution # 法一 简单模拟 + 字符串，如果你是刚刚学字符串的萌新，推荐先看看 这题，这两题类似，都是统计一个字符串里面的字符的情况。 那么我们可以定义两个变量分别存储 000 的出现次数和 111 的出现次数。 # Code\\sf CodeCode 1234567891011121314151617181920212223242526272829/* Problem:CF1373B Date:28/06/20 21:29*/#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define line cout &lt;&lt; endlusing namespace std;int t;int main () &#123; cin &gt;&gt; t; int _1, _0; while (t--) &#123; string s; cin &gt;&gt; s; int len = s.length(); for (int i = 0; i &lt; len; i++) &#123; if (s[i] == &#x27;1&#x27;) _1++;//如果当前字符是1 else _0++; &#125; cout &lt;&lt; (min (_1, _0) % 2 == 0 ? &quot;NET&quot; : &quot;DA&quot;) &lt;&lt; endl;//取最小值/判断奇偶/输出 _1 = 0, _0 = 0;//清零 &#125; return 0;&#125; # 法二 利用 c++ 的 STL 中的 count 函数。 count 的用法： count 共有 3 个参数： count(begin, end, c); 其中 begin 代表字符串的起始位置，end 代表终止位置，c 代表要统计的字符。 那在这道题里面，我们就可以用 count 函数统计 000 和 111 的个数。 # Code\\sf CodeCode 1234567891011121314151617181920212223/* Problem:CF1373B Date:28/06/20 21:29*/#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define line cout &lt;&lt; endlusing namespace std;int t;int main () &#123; cin &gt;&gt; t; int _1, _0; while (t--) &#123; string s; cin &gt;&gt; s; cout &lt;&lt; (min (count (s.begin (), s.end (), &#x27;0&#x27;), count (s.begin (), s.end (), &#x27;1&#x27;)) % 2 == 0 ? &quot;NET&quot; : &quot;DA&quot;) &lt;&lt; endl;//统计/取最小值/判断奇偶/输出 &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/"},{"name":"CodeForces","slug":"题解/CodeForces","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/CodeForces/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://blog.geometry37.tk/t/%E6%A8%A1%E6%8B%9F/"},{"name":"字符串","slug":"字符串","permalink":"https://blog.geometry37.tk/t/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"[UVA10116]Robot Motion","slug":"[UVA10116]Robot-Motion","date":"2020-12-25T13:48:41.000Z","updated":"2021-01-14T13:24:36.966Z","comments":true,"path":"p/uva10116/","link":"","permalink":"https://blog.geometry37.tk/p/uva10116/","excerpt":"","text":"# Simple Translation 让你模拟一个机器人行走的过程，如果机器人走入了一个循环，输出不是循环的长度和是循环的长度，如果最终走出来了，输出走的步数。 # Solution 直接模拟即可，本题难度主要是判断循环，但是其实一点也不难。 首先定义一个 aaa 二维数组，然后将 a0,i,am+1,i,ai,0,ai,n+1a_{0, i}, a_{m+1, i}, a_{i, 0}, a_{i, n+1}a0,i​,am+1,i​,ai,0​,ai,n+1​ 全部赋值为 111，这是因为我们可以通过 aaa 数组来判断机器人走没走出地图。 循环模拟机器人走的每一步，并把走到这个地方所花费的步数记录在 ax,ya_{x, y}ax,y​，每当发现 ax,ya_{x, y}ax,y​ 走过时，即 ax,y≠0a_{x, y} \\neq 0ax,y​=0 时，退出循环。 当机器人已经走出地图时，输出 ax,ya_{x, y}ax,y​。 否则，输出未循环的步数和循环的步数，如何算这两个数呢？ 我们发现总共走的步数是记录在 ax,ya_{x, y}ax,y​ 里面的，而我们走到的下一个格子就是循环的开始，所以只要求一下差值，即可得到。 # Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define line cout &lt;&lt; endlusing namespace std;int a[13][13];char mapp[11][11];int m, n;int main() &#123; while (cin &gt;&gt; n &gt;&gt; m) &#123; if (m == 0 &amp;&amp; n == 0) break; memset (a, 0, sizeof(a)); for (int i = 0; i &lt; m + 2; i++) &#123;//将边缘全部变为 1 ，下同 a[0][i] = 1; a[m + 1][i] = 1; &#125; for (int i = 0; i &lt; n + 2; i++) &#123; a[i][0] = 1; a[i][n + 1] = 1; &#125; int x = 1, y = 1;//记录当前坐标 cin &gt;&gt; x; for (int j = 1; j &lt;= n; j++) &#123; for (int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; mapp[i][j]; &#125; &#125; int xx = x, yy = y;//记录下一个坐标 while (!a[xx][yy]) &#123;//如果下一个格子没走过 a[xx][yy] = 1 + a[x][y];//记录步数 x = xx;//更新坐标 y = yy; switch (mapp[xx][yy]) &#123; case &#x27;N&#x27;: yy--; break; case &#x27;S&#x27;: yy++; break; case &#x27;W&#x27;: xx--; break; case &#x27;E&#x27;: xx++; break; &#125; &#125; if (xx &lt;= 0 || xx &gt; m || yy &lt;= 0 || yy &gt; n) &#123; //如果已经到达边缘 cout &lt;&lt; a[x][y] &lt;&lt; &quot; step(s) to exit&quot; &lt;&lt; endl; &#125; else &#123; int s = a[x][y] - (a[x][y] - a[xx][yy] + 1);//求未进如循环的步数 cout &lt;&lt; s &lt;&lt; &quot; step(s) before a loop of &quot; &lt;&lt; a[x][y] - a[xx][yy] + 1 &lt;&lt; &quot; step(s)&quot; &lt;&lt; endl; &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/"},{"name":"UVA","slug":"题解/UVA","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/UVA/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://blog.geometry37.tk/t/%E6%A8%A1%E6%8B%9F/"}]},{"title":"[CF363A]Soroban","slug":"[CF363A]Soroban","date":"2020-12-25T13:47:16.000Z","updated":"2021-01-31T14:19:44.156Z","comments":true,"path":"p/cf363a/","link":"","permalink":"https://blog.geometry37.tk/p/cf363a/","excerpt":"","text":"# solution 这题就是个纯模拟，首先我们根据输出样例看一下输出算盘的规则。 看数最大的 720 ，我们发现，输出的算盘张这样（之所以我不用代码框而用 KaTeX\\KaTeXKATE​X 是因为代码框是对不了齐的）： O−∣−OOOOO−∣OO−OO−O∣OO−OO\\begin{matrix} O &amp; - &amp; | &amp; - &amp; O &amp; O &amp; O &amp; O \\\\ O &amp; - &amp; | &amp; O &amp; O &amp; - &amp; O &amp; O \\\\ - &amp; O &amp; | &amp; O &amp; O &amp; - &amp; O &amp; O \\\\ \\end{matrix} OO−​−−O​∣∣∣​−OO​OOO​O−−​OOO​OOO​ 其中左面一个珠子代表 555，下面一个珠子代表 111，从 下往上 读。 先看最高位。 −O∣OO−OO\\begin{matrix} - &amp; O &amp; | &amp; O &amp; O &amp; - &amp; O &amp; O \\\\ \\end{matrix} −​O​∣​O​O​−​O​O​ 看到代表 555 的珠子是往中间拨的，有两个代表 111 的珠子也是往中间拨的，所以最高位就等于 5×1+1×2=75 \\times 1 + 1 \\times 2 = 75×1+1×2=7 再看十位。 O−∣OO−OO\\begin{matrix} O &amp; - &amp; | &amp; O &amp; O &amp; - &amp; O &amp; O \\\\ \\end{matrix} O​−​∣​O​O​−​O​O​ 代表 555 的珠子是没有往中间拨的，有两个代表 111 的珠子是往中间拨的，所以十位就等于 =5×0+1×2=2=5 \\times 0 + 1 \\times 2 = 2=5×0+1×2=2 最后看个位。 O−∣−OOOO\\begin{matrix} O &amp; - &amp; | &amp; - &amp; O &amp; O &amp; O &amp; O \\\\ \\end{matrix} O​−​∣​−​O​O​O​O​ 代表 555 的珠子没有往中间拨的，代表 111 的珠子也没有是往中间拨的，所以个位就等于 =5×0+1×0=0=5 \\times 0 + 1 \\times 0 = 0=5×0+1×0=0 最后相结合 百位十位个位720=720\\begin{matrix} \\text{百位} &amp; \\text{十位} &amp; \\text{个位}\\\\ 7 &amp; 2 &amp; 0\\\\ \\end{matrix}=720 百位7​十位2​个位0​=720 那我们就可以打一个表，将 1∼101 \\sim 101∼10 算盘对应的状态打成表，最后字符串输入一位一位看即可。 # Code 123456789101112131415161718192021222324252627282930313233/* Problem:CF363A*/#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define line cout &lt;&lt; endlusing namespace std;char n[15];string abacus[15] = &#123; &quot;O-|-OOOO&quot;,//0 &quot;O-|O-OOO&quot;,//1 &quot;O-|OO-OO&quot;,//2 &quot;O-|OOO-O&quot;,//3 &quot;O-|OOOO-&quot;,//4 &quot;-O|-OOOO&quot;,//5 &quot;-O|O-OOO&quot;,//6 &quot;-O|OO-OO&quot;,//7 &quot;-O|OOO-O&quot;,//8 &quot;-O|OOOO-&quot;//9&#125;;int main () &#123; cin &gt;&gt; n; int len = strlen (n); for (int i = len - 1; i &gt;= 0; i--) &#123; //注意！输出是从低位到高位！ cout &lt;&lt; abacus[n[i] - &#x27;0&#x27;] &lt;&lt; endl; &#125; return 0;&#125; 谢谢。","categories":[{"name":"题解","slug":"题解","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/"},{"name":"CodeForces","slug":"题解/CodeForces","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/CodeForces/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://blog.geometry37.tk/t/%E6%A8%A1%E6%8B%9F/"},{"name":"字符串","slug":"字符串","permalink":"https://blog.geometry37.tk/t/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"[UVA11626]Convex Hull","slug":"[UVA11626]Convex-Hull","date":"2020-12-25T13:46:12.000Z","updated":"2021-01-13T12:59:20.263Z","comments":true,"path":"p/uva11626/","link":"","permalink":"https://blog.geometry37.tk/p/uva11626/","excerpt":"","text":"凸包模板题。 之前写过拿 Graham 算法求凸包的，为了不重复 / 多学点知识，那这次拿 Andrew 算法求凸包吧 qaq * 此文章所有图片均为作者手画。 # Andrew 算法 假设我们有这些点： 首先把所有点以横坐标为第一关键字，纵坐标为第二关键字排序。 相对于 Graham 算法来说，Andrew 算法排序更简单，按 x,yx, yx,y 坐标排序，时间复杂度也更低（一般的坐标系中排序方法）。 首先将 p1p_1p1​ 入栈。 然后也将 p2p_2p2​ 入栈，p2p_2p2​ 可能在，也可能不在，等着之后判断。 随后，发现 p3p_3p3​ 偏右，所以我们将 p2p_2p2​ 出栈。 发现 p4p_4p4​ 依然偏右，p3p_3p3​ 出栈，p4p_4p4​ 入栈。 p5p_5p5​ 向右，p4p_4p4​ 出栈，p5p_5p5​ 入栈。 p6p_6p6​ 向左，入栈。 p7p_7p7​ 向右，p6p_6p6​ 出栈，p7p_7p7​ 入栈。 p8p_8p8​ 向右，p7p_7p7​ 出栈，继续检查发现相对于 p5p_5p5​ p8p_8p8​ 仍然向右，p5p_5p5​ 出栈，p8p_8p8​ 入栈。 此时，我们发现，凸包明明还空一半就到头了？？？ 然而这是意料之中，我们这种算法必然会只算出一半的凸包。 所以我们需要再从排序末尾的点（也就是 p8p_8p8​）出发，按照一模一样的方式再算一遍就行了。 当然如果我们走过的点就不许要再走了（除了 p1p_1p1​） 从 p8p_8p8​ 到 p7p_7p7​，向左，p7p_7p7​ 入栈。 p6p_6p6​ 向右，p7p_7p7​ 出栈，p6p_6p6​ 入栈。 p5p_5p5​ 向左，入栈。 p4p_4p4​ 向左，入栈。 p3p_3p3​ 向右，p4p_4p4​ 出栈，对于 p5p_5p5​ p3p_3p3​ 依然向右，p5p_5p5​ 出栈，p3p_3p3​ 入栈。 p2p_2p2​ 向右，p3p_3p3​ 出栈，p2p_2p2​ 入栈。 最后将 p2p_2p2​ 和 p1p_1p1​ 连起来。 至此，我们的 Andrew 算法就完成了！ 扫描的时间复杂度：O(n)O(n)O(n)（已过滤常数） 排序时间复杂度：O(nlog⁡n)O(n \\log n)O(nlogn) 总时间复杂度：O(nlog⁡n)O(n \\log n)O(nlogn) # Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define line cout &lt;&lt; endlusing namespace std;const int NR = 1e5 + 5;const double eps = 1e-7;int n;struct point &#123; double x, y; point () &#123;&#125; point (double a, double b) : x (a), y (b) &#123;&#125; bool operator &lt; (const point &amp;b) const &#123; if (x &lt; b.x) return 1; if (x &gt; b.x) return 0; return y &lt; b.y; &#125; point operator - (const point &amp;b) &#123; return point (x - b.x, y - b.y); &#125;&#125;;point p[NR], sp[NR];int cmp (double x) &#123; if (fabs (x) &lt; eps) return 0; return x &gt; 0 ? 1 : -1;&#125;double dis (point a, point b) &#123; return sqrt ((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));&#125;double cp (point a, point b) &#123; return a.x * b.y - a.y * b.x;&#125;int Andrew () &#123; sort (p + 1, p + 1 + n); int len = 0; for (int i = 1; i &lt;= n; i++) &#123; while (len &gt; 1 &amp;&amp; cmp (cp (sp[len] - sp[len - 1], p[i] - sp[len - 1])) &lt; 0) len--; sp[++len] = p[i]; &#125; int k = len; for (int i = n - 1; i &gt;= 1; i--) &#123; while (len &gt; k &amp;&amp; cmp (cp (sp[len] - sp[len - 1], p[i] - sp[len - 1])) &lt; 0) len--; sp[++len] = p[i]; &#125; return len;&#125;int main () &#123; int t; cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; n; char c; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; p[i].x &gt;&gt; p[i].y &gt;&gt; c; int t = Andrew(); cout &lt;&lt; t - 1 &lt;&lt; endl; for (int i = 1; i &lt; t; i++) printf (&quot;%.0lf %.0lf\\n&quot;, sp[i].x, sp[i].y); &#125; return 0;&#125; 谢谢 qaq","categories":[{"name":"题解","slug":"题解","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/"},{"name":"UVA","slug":"题解/UVA","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/UVA/"}],"tags":[{"name":"计算几何","slug":"计算几何","permalink":"https://blog.geometry37.tk/t/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"},{"name":"凸包","slug":"凸包","permalink":"https://blog.geometry37.tk/t/%E5%87%B8%E5%8C%85/"}]},{"title":"[UVA681]Convex Hull Finding","slug":"[UVA681]Convex-Hull-Finding","date":"2020-12-25T13:44:59.000Z","updated":"2021-01-13T12:59:08.839Z","comments":true,"path":"p/uva681/","link":"","permalink":"https://blog.geometry37.tk/p/uva681/","excerpt":"","text":"更改了一下程序的错误。 # Translation 找出凸包，然后逆时针输出每个点，测试数据中没有相邻的边是共线的。多测。 # Solution 首先推销一下作者的笔记 由此进入 &gt;&gt;&gt; （ 明显是一道二维凸包模板。 在这里，我们简单讲一下二维凸包。 「 在平面上能包含所有给定点的最小凸多边形叫做凸包。 其定义为：对于给定集合 XXX ，所有包含 XXX 的凸集的交集 SSS 被称为 XXX 的 凸包 。 \\qquad\\qquad —— OI-Wiki 」 其实我们可以把凸包看成一个拿橡皮筋围成的一个图形。 假设有一个布满小凸起的板子： 我们要把这些凸起都围起来，怎么围呢？ 显然，最简单方变的方法是这样： 但是，我们知道，橡皮筋是有弹力的，所以橡皮筋会往里缩，直到这样： 最外圈的凸起撑起了橡皮筋。 此时橡皮筋围成的多边形的顶点就是最外圈凸起所在的位置。 由此，我们就定义橡皮筋围成的图形为一个平面凸包。 那么，换一种定义，就为： 平面凸包是指覆盖平面上 nnn 个点的最小的凸多边形。 当然，我们发现在程序中却无法模拟橡皮筋收缩的过程，于是有了下文的诞生。 # 二维凸包的求法 # 斜率逼近法 其实这也是一种容易想到的算法，但是并不常用（代码复杂度高），所以我们省略带过。 # Jarvis 算法 这其实是一种数学构造法 此算法的时间复杂度为 O(nm)O(nm)O(nm)。 但是，这个复杂度会爆炸。 于是我们伟大的 OIer\\sf OIerOIer 就想到了 Graham 算法。 # Graham 算法 Graham 算法的本质： Graham 扫描算法维护一个凸壳，通过不断在凸壳中加入新的点和去除影响凸性的点，最后形成凸包。 凸壳：凸包的一部分。 此算法主要分为两部分： 排序 扫描 # 排序 我们先选择一个 yyy 最小的点（如 yyy 相同选 xxx 最小），记为 p1p_1p1​。 剩下的点，按照极角的大小逆时针排序，记为 p1,p2,…,pmp_1,p_2,\\dots, p_mp1​,p2​,…,pm​。 我们按照排序结束时的顺序枚举每一个点，依次连线，这里可以使用一个栈来存储，每次入栈，如果即将入栈的元素与栈顶两个元素所构成了一个类似于凹壳的东西，那么显然处于顶点的那个点一定不在这个点集的凸包上，而他正好在栈顶，所以把它弹出栈，新点入栈。 # 扫描 （下列所说的左右等是指以上一条连线为铅垂线，新的连线偏移的方向） 刚开始，我们的点集是这样的： p1p_1p1​ 为起始点。 随后，p2p_2p2​ 准备入栈，由于栈元素很少，所以可以入栈。 再看 p3p_3p3​，因为 p3p_3p3​ 向左，符合凸包条件，入栈。 随后 p4p_4p4​ 也一切正常，依然向左，入栈。 p5p_5p5​ 依然向左，入栈。 到 p6p_6p6​ 时，我们发现了点问题，就是不再是向左了，而是向右了，所以我们此时要将 p5p_5p5​ 出栈，p6p_6p6​ 入栈。 入栈后，我们发现，相对于 p4p_4p4​，p6p_6p6​ 依然是向右的，所以我们还要把 p4p_4p4​ 出栈，p6p_6p6​ 入栈。 接下来 p7p_7p7​ 没有问题。 p8p_8p8​ 时，我们发现，也是向右的，所以将 p7p_7p7​ 出栈，p8p_8p8​ 入栈。 接下来 p9p_9p9​ 正常，入栈。 最后，我们再把最后一个点和第一个点连起来。 此时，我们的 Graham 算法的全过程就结束了。 扫描的时间复杂度：O(n)O(n)O(n)。 但是不可能那么优秀，还要加上排序的时间复杂度：O(nlog⁡n)O(n\\log n)O(nlogn)。 所以总时间复杂度为 O(nlog⁡n)O(n \\log n)O(nlogn)。 可见此算法相比之前的算法优秀的多。 这道题，我们就用 Graham 算法求凸包。 直接按照 Graham 算法思路一步一步走即可。 # Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/* Problem:UVA681 Date:02/07/20 14:56*/#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define line cout &lt;&lt; endlusing namespace std;const int NR = 1e6 + 5;int t;int n;struct point &#123; int x, y;&#125;;point p[NR], ps[NR];double dis (point pa, point pb) &#123; return sqrt (1.0 * (pb.x - pa.x) * (pb.x - pa.x) + 1.0 * (pb.y - pa.y) * (pb.y - pa.y));&#125;int cp (point pa1, point pa2, point pb1, point pb2) &#123; return (pa2.x - pa1.x) * (pb2.y - pb1.y) - (pb2.x - pb1.x) * (pa2.y - pa1.y);&#125;bool cmp (point px, point py) &#123; if (px.x == py.x &amp;&amp; px.y == py.y) return false; int num = cp (p[1], px, p[1], py); if (num &gt; 0) return true; if (num == 0 &amp;&amp; dis (p[0], px) &lt; dis (p[0], py)) return true; return false;&#125;int convex_hull () &#123; sort (p + 2, p + n + 1, cmp); ps[1] = p[1]; int h = 1; for (int i = 2; i &lt;= n; i++) &#123; while (h &gt; 1 &amp;&amp; cp (ps[h - 1], ps[h], ps[h], p[i]) &lt;= 0) &#123; h--; &#125; h++; ps[h] = p[i]; &#125; ps[h + 1] = p[1]; return h;&#125;void _memset () &#123; memset (p, 0, sizeof p); memset (ps, 0, sizeof ps); return;&#125;int main () &#123;// freopen (&quot;UVA681.in&quot;, &quot;r&quot;, stdin);// freopen (&quot;UVA681.out&quot;, &quot;w&quot;, stdout); cin &gt;&gt; t; cout &lt;&lt; t &lt;&lt; endl; while (t--) &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; p[i].x &gt;&gt; p[i].y; if(i != 1 &amp;&amp; p[i].y &lt; p[1].y) &#123; swap (p[i].y, p[1].y); swap (p[i].x, p[1].x); &#125; &#125; if (t &gt;= 1) &#123; int a; cin &gt;&gt; a; &#125; int h = convex_hull (); cout &lt;&lt; h + 1 &lt;&lt; endl; for (int i = 1; i &lt;= h; i++) &#123; cout &lt;&lt; ps[i].x &lt;&lt; &quot; &quot; &lt;&lt; ps[i].y &lt;&lt; endl; &#125; cout &lt;&lt; ps[1].x &lt;&lt; &quot; &quot; &lt;&lt; ps[1].y &lt;&lt; endl; if (t &gt;= 1) &#123; cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl; &#125; _memset (); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/"},{"name":"UVA","slug":"题解/UVA","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/UVA/"}],"tags":[{"name":"计算几何","slug":"计算几何","permalink":"https://blog.geometry37.tk/t/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"},{"name":"凸包","slug":"凸包","permalink":"https://blog.geometry37.tk/t/%E5%87%B8%E5%8C%85/"}]},{"title":"[CF1352A]Sum of Round Numbers","slug":"[CF1352A]Sum-of-Round-Numbers","date":"2020-12-25T13:43:59.000Z","updated":"2021-01-31T14:19:28.994Z","comments":true,"path":"p/cf1352a/","link":"","permalink":"https://blog.geometry37.tk/p/cf1352a/","excerpt":"","text":"应该是纯模拟吧。 直接输入一个字符串，然后一位一位看，如果不是 0，就 k++ ，并计算这个数的真实的值，最后输出就行了。 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define line cout &lt;&lt; endlusing namespace std;int t, k, sum = 1/*位数*/, a[10], cnt;char n[10];int main() &#123; cin &gt;&gt; t;//T组数据 for (int T = 1; T &lt;= t; T++) &#123; cin &gt;&gt; n; int len = strlen(n); for (int i = len - 1; i &gt;= 0; i--) &#123; if (n[i] != &#x27;0&#x27;) &#123;//如果这一位不是0 k++;//总数++ a[++cnt] = (n[i] - &#x27;0&#x27;) * sum;//算一下这一位真实的值 &#125; sum *= 10;//位数++ &#125; cout &lt;&lt; k; line; for (int i = 1; i &lt;= cnt; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; &#125; line; k = 0;//初始化 sum = 1;//初始化 memset(a, 0, sizeof(a));//初始化 cnt = 0;//初始化 &#125; return 0;&#125; CF 记录","categories":[{"name":"题解","slug":"题解","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/"},{"name":"CodeForces","slug":"题解/CodeForces","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/CodeForces/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://blog.geometry37.tk/t/%E6%A8%A1%E6%8B%9F/"},{"name":"字符串","slug":"字符串","permalink":"https://blog.geometry37.tk/t/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"","slug":"[CF675A]Infinite-Sequence","date":"2020-12-25T13:42:35.566Z","updated":"2021-01-31T14:19:33.519Z","comments":true,"path":"p/undefined/","link":"","permalink":"https://blog.geometry37.tk/p/undefined/","excerpt":"","text":"title: ‘[CF1182B] Plus from Picture’ tags: [模拟，搜索] url: cf1182b date: 2020-12-25 21:53:40 categories: [题解，CodeForces] katex: true 这是一道超级水的模拟 + 简单搜索。 说说思路： 先找到中心点，就是自己和上下左右都为 * 的。 上下左右上的所有 * 都删掉，然后再看看有没有多余的 * 如果有输出 NO 否则输出 YES 。 比如说有这样一个 n=5n = 5n=5 的图： ....∗..∗...∗∗∗∗..∗....∗..\\begin{matrix} .&amp;.&amp;.&amp;.&amp;*\\\\ .&amp;.&amp;*&amp;.&amp;.\\\\ .&amp;*&amp;*&amp;*&amp;*\\\\ .&amp;.&amp;*&amp;.&amp;.\\\\ .&amp;.&amp;*&amp;.&amp;. \\end{matrix}.....​..∗..​.∗∗∗∗​..∗..​∗.∗..​ 首先一个一个找，当找到一个点，自己本身和上下左右均为 ∗*∗ 时（如图中 aaa 点）： ....∗..∗...∗a∗∗..∗....∗..\\begin{matrix} .&amp;.&amp;.&amp;.&amp;*\\\\ .&amp;.&amp;*&amp;.&amp;.\\\\ .&amp;*&amp;a&amp;*&amp;*\\\\ .&amp;.&amp;*&amp;.&amp;.\\\\ .&amp;.&amp;*&amp;.&amp;. \\end{matrix}.....​..∗..​.∗a∗∗​..∗..​∗.∗..​ 将上下左右上的一条全部变为 ∗*∗： ....∗....................\\begin{matrix} .&amp;.&amp;.&amp;.&amp;*\\\\ .&amp;.&amp;.&amp;.&amp;.\\\\ .&amp;.&amp;.&amp;.&amp;.\\\\ .&amp;.&amp;.&amp;.&amp;.\\\\ .&amp;.&amp;.&amp;.&amp;. \\end{matrix}.....​.....​.....​.....​∗....​ 那我们就会发现图中还有 ∗*∗ 没有变成 ... 这就说明此加号不合法。 上代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/* Problem:CF1182B Date:14/06/20 12:02*/#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define line cout &lt;&lt; endl#define int long long using namespace std;char ma[2005][2005];int h, w;bool flag;void up (int i, int j) &#123; ma[i][j] = &#x27;.&#x27;; if (ma[i - 1][j] == &#x27;*&#x27;) return up(i - 1, j);&#125;void down (int i, int j) &#123; ma[i][j] = &#x27;.&#x27;; if (ma[i + 1][j] == &#x27;*&#x27;) return down(i + 1, j);&#125;void left (int i, int j) &#123; ma[i][j] = &#x27;.&#x27;; if (ma[i][j - 1] == &#x27;*&#x27;) left(i, j - 1);&#125;void right (int i, int j) &#123; ma[i][j] = &#x27;.&#x27;; if (ma[i][j + 1] == &#x27;*&#x27;) return right(i, j + 1);&#125;void kill (int i, int j) &#123; ma[i][j] = &#x27;.&#x27;; up (i - 1, j); down (i + 1, j); left (i, j - 1); right (i, j + 1);&#125;void test () &#123;//测试(i,j)是不是一个加号的中心 for (int i = 1; i &lt;= h; i++) &#123; for (int j = 1; j &lt;= w; j++) if (ma[i][j] == &#x27;*&#x27; &amp;&amp; ma[i - 1][j] == &#x27;*&#x27; &amp;&amp; ma[i][j - 1] == &#x27;*&#x27; &amp;&amp; ma[i + 1][j] == &#x27;*&#x27; &amp;&amp; ma[i][j + 1] == &#x27;*&#x27;) &#123;//对第一个可能的十字的中心 kill (i, j);//抹去这个十字 flag = true; break; &#125; if (flag) break; &#125; for (int i = 1; i &lt;= h; i++)//这时,应没有&#x27;*&#x27;了 for (int j = 1; j &lt;= w; j++) if (ma[i][j] == &#x27;*&#x27;) flag = false;&#125;signed main () &#123; cin &gt;&gt; h &gt;&gt; w; for(int i = 1; i &lt;= h; i++) for(int j = 1; j &lt;= w; j++) cin &gt;&gt; ma[i][j]; test(); if(flag) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); return 0;&#125;谢谢。","categories":[],"tags":[]},{"title":"[P1504]积木城堡","slug":"[P1504]积木城堡","date":"2020-12-25T13:40:13.000Z","updated":"2021-01-31T14:19:24.476Z","comments":true,"path":"p/p1504/","link":"","permalink":"https://blog.geometry37.tk/p/p1504/","excerpt":"","text":"这题是 01 背包（DPDPDP) 如何判断要拆走那个积木，首先定义一个ansansans 数组，来存放这对积木能拼成多高的，然后如果ansi=nans_i = nansi​=n 那么就说明这个高度的积木可以。 # 话不多说，上代码！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt; //从最小高度~1枚举, 如果能恰好达到这个高度（即用它有的积木恰好能拼出）有n个城堡#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int n, len, min_high = 2e9;//n表示城堡数,len表示每块立方体积木的棱长, min_high表示所有城堡初始高度最小值 int w[10005],ans[10005]; //设ans[i]表示i能被多少组w[1..n]凑成，当dp[i]==true时，ans[i]++//w[i]表示组成这座城堡的第i块积木的棱长 bool dp[10005]; //dp[i]表示能否使用当前的w[1..n]相加得到i/* 有n件物品(积木)，每件物品体积(积木的棱长)为w[i], 价值(积木的棱长)为w[i]。有容量(城堡高度)为 V 的背包(城堡)。求在容量(城堡高度)允许的范围下，背包装入物品的价值和(积木的棱长和)有哪些可能值。*/ int main()&#123; scanf(&quot;%d&quot;, &amp;n); for(int k = 1; k &lt;= n; k++) &#123; memset(dp, 0, sizeof(dp)); int cnt = 1, high = 0; //cnt表示每座城堡含积木的块数，high表示每座城堡的初始高度 while(1) &#123; scanf(&quot;%d&quot;, &amp;w[cnt]); //len表示组成这座城堡的每块积木的棱长 if(w[cnt] == -1) break; high += w[cnt]; cnt++; &#125; dp[0] = 1; // dp[0] = 1表示能使用当前的w[1..n]相加得到高度0 min_high = min(min_high, high); //求出所有城堡初始高度最小值 for(int i = 1; i &lt; cnt; i++) //对每座城堡从1~g去枚举每一块积木 for(int j = high; j &gt;= w[i]; j--) dp[j] = dp[j] || dp[j-w[i]]; //01背包变形，即动态转移方程 for(int i = high; i &gt;= 1; i--) if(dp[i] == true) ans[i]++; //统计高度i出现次数 &#125; for(int i = min_high; i &gt;= 1; i--) //从最小高度~1枚举 if(ans[i] == n) //如果能恰好达到这个高度（即用它有的积木恰好能拼出）有n个城堡 &#123; printf(&quot;%d\\n&quot;, i); return 0; &#125; printf(&quot;0\\n&quot;); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/"},{"name":"Luogu","slug":"题解/Luogu","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/Luogu/"}],"tags":[{"name":"枚举,暴力","slug":"枚举-暴力","permalink":"https://blog.geometry37.tk/t/%E6%9E%9A%E4%B8%BE-%E6%9A%B4%E5%8A%9B/"},{"name":"背包","slug":"背包","permalink":"https://blog.geometry37.tk/t/%E8%83%8C%E5%8C%85/"},{"name":"动态规划,动规,dp","slug":"动态规划-动规-dp","permalink":"https://blog.geometry37.tk/t/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%8A%A8%E8%A7%84-dp/"}]},{"title":"各省省选题解总集","slug":"各省省选题解总集","date":"2020-12-25T13:35:07.000Z","updated":"2021-01-13T12:59:28.706Z","comments":true,"path":"p/各省省选题解总集/","link":"","permalink":"https://blog.geometry37.tk/p/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89%E9%A2%98%E8%A7%A3%E6%80%BB%E9%9B%86/","excerpt":"","text":"# 2001 # P2550 [AHOI2001] 彩票摇奖 emmm… 没什么可讲的吧，直接模拟题意即可。 123456789101112131415161718192021222324252627282930313233/* Problem:P2550*/#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define line cout &lt;&lt; endlusing namespace std;int n;int stOurist_SC_MiFaFaOvOrz;int Baylor_cute;int qq_Baylor[50];int stO_SC[10];int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= 7; i++) &#123; cin &gt;&gt; stOurist_SC_MiFaFaOvOrz; qq_Baylor[stOurist_SC_MiFaFaOvOrz] = 1; &#125; for (int i = 1; i &lt;= n; i++) &#123; int sum = 0; for (int j = 1; j &lt;= 7; j++) &#123; cin &gt;&gt; Baylor_cute; if(qq_Baylor[Baylor_cute] == 1) sum++; &#125; stO_SC[sum]++; &#125; for(int i = 7; i &gt;= 1; i--) cout &lt;&lt; stO_SC[i] &lt;&lt; &quot; &quot;; return 0;&#125; # P2563 [AHOI2001] 质数和分解 依然很水，是一道简单的 dp 背包题，打一个质数表。 转移方程很容易看出： dp[j]=dp[j]+dp[j+prime[i]]\\rm dp[j] = dp[j] + dp[j + prime[i]]dp[j]=dp[j]+dp[j+prime[i]] 1234567891011121314151617181920212223242526272829303132/* Problem:P2563*/#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define line cout &lt;&lt; endlusing namespace std;int prime[205], dp[205];bool Prime (int x) &#123; if(x == 2) return 1; for(int i = 2; i &lt; x; i++) if(x % i == 0) return 0; return 1;&#125;int main () &#123; dp[0] = 1; int n; int cnt = 0; for (int i = 2; i &lt;= 200; i++) if (Prime (i) == 1) prime[++cnt] = i; for (int i = 1; i &lt;= cnt; i++) for (int j = prime[i]; j &lt;= 200; j++) dp[j] = dp[j] + dp[j - prime[i]]; while (cin &gt;&gt; n) cout &lt;&lt; dp[n] &lt;&lt; endl; return 0;&#125; # 2002 # P1434 [SHOI2002] 滑雪 这题超水，就是一个简单的 dfs，应该没什么多讲的。 123456789101112131415161718192021222324252627282930313233343536373839/* Problem:P1434*/#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define line cout &lt;&lt; endlusing namespace std;int n, m;int a[105][105], s[105][105], ans;int dx[4] = &#123;0, 0, 1, -1&#125;;int dy[4] = &#123;1, -1, 0, 0&#125;;int dfs (int x, int y) &#123; if (s[x][y]) return s[x][y]; s[x][y] = 1; for (int i = 0; i &lt;= 3; i++) &#123; int x_new = x + dx[i], y_new = y + dy[i]; if (x_new &gt; 0 &amp;&amp; x_new &lt;= n &amp;&amp; y_new &gt; 0 &amp;&amp; y_new &lt;= m &amp;&amp; a[x][y] &gt; a[x_new][y_new]) &#123; dfs(x_new, y_new); s[x][y] = max(s[x_new][y_new] + 1, s[x][y]); &#125; &#125; return s[x][y];&#125;int main () &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) cin &gt;&gt; a[i][j]; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) ans = max (ans, dfs (i, j)); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; # 2008 # P3197 [HNOI2008] 越狱 如果去暴力算，会 TLE，所以要用费马小定理或快速幂去做。 # 费马小定理 123456789101112131415161718192021222324252627/* Problem:P3197*/#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define line cout &lt;&lt; endlusing namespace std;const int mod = 100003;int main () &#123; long long n, m; cin &gt;&gt; m &gt;&gt; n; m %= mod; n %= (mod - 1); long long ans1 = m, ans2 = m; for (int i = 1; i &lt; n; i++) &#123; ans1 *= m; ans1 %= mod; ans2 *= m - 1; ans2 %= mod; &#125; cout &lt;&lt; (ans1 - ans2 + mod) % mod &lt;&lt; endl; return 0;&#125; # 快速幂 123456789101112131415161718192021222324252627282930313233343536/* Problem:P3197*/#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define line cout &lt;&lt; endlusing namespace std;const int mod = 100003;long long ksm (long long a, long long b) &#123; long long sum = 1; a %= mod; while (b &gt; 0) &#123; if(b % 2 == 1) sum = (sum * a) % mod; b /= 2; a = (a * a) % mod; &#125; return sum;&#125;int main () &#123; long long n, m; cin &gt;&gt; m &gt;&gt; n; m %= mod; long long ans1 = m, ans2 = m; ans1 *= ksm (m, n - 1); ans1 %= mod; ans2 *= ksm (m - 1, n - 1); ans2 %= mod; ans1 += mod; cout &lt;&lt; (ans1 - ans2) % mod &lt;&lt; endl; return 0;&#125; # 2012 # P3829 [SHOI2012] 信用卡凸包 那道题很水，建议马上去切了 我一遍 A —— limaopipi2022 确实很水 卡了我一个星期，不过理解了就是二维凸包板子。 把信用卡的那四个 14\\dfrac{1}{4}41​ 圆去掉，切成长方形，把 4 个点加入点集做个凸包，最后加上圆的周长。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/* Problem:P3829*/#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define line cout &lt;&lt; endl#define DEBUG cout &lt;&lt; &quot;JXU2MjExJXU2QzM4JXU4RkRDJXU3MjMxQmF5bG9yJXVGRjAx&quot; &lt;&lt; endl;using namespace std;const int NR = 1e5 + 5;const double pi = 3.1415926535;struct point &#123;double x, y;&#125;;int n, h, cnt;double a, b, r, ans;point p[NR], ps[NR];double square (double xxx) &#123;return xxx * xxx;&#125;//去世原因，把这里参数写成了 int ……bool cmp (point x, point y) &#123; if (x.y != y.y) return x.y &gt; y.y; return x.x &gt; y.x;&#125;double dis (point a, point b) &#123;return sqrt (square (a.x - b.x) + square (a.y - b.y));&#125;double qaq (point a, point b, point c) &#123;return a.x * b.y + a.y * c.x + b.x * c.y - a.x * c.y - a.y * b.x - b.y * c.x;&#125;void Convex_Hull () &#123; h = n + 1; cnt = n + 1; ps[cnt++] = p[1]; int i; for (i = 1; i &lt;= n; i++) &#123; ps[cnt] = p[i]; if (qaq (ps[n], p[i], p[i + 1])) break; &#125; if (n &lt; 2) return; ps[++cnt] = ps[--h] = p[++i]; if (qaq (ps[n - 1], ps[n], ps[n + 1]) &lt; 0) swap (ps[n - 1], ps[n]); for (++i; i &lt;= n; i++) &#123; if (qaq (ps[h + 1], ps[h], p[i]) &lt; 0 &amp;&amp; qaq (ps[cnt - 1], ps[cnt], p[i]) &gt; 0) continue; while (cnt - h &gt; 1 &amp;&amp; qaq (ps[h + 1], ps[h], p[i]) &gt;= 0) h++; ps[--h] = p[i]; while (cnt - h &gt; 1 &amp;&amp; qaq (ps[cnt - 1], ps[cnt], p[i]) &lt;= 0) cnt--; ps[++cnt] = p[i]; &#125;&#125;int main () &#123; cin &gt;&gt; n; cin &gt;&gt; a &gt;&gt; b &gt;&gt; r; a -= r * 2; b -= r * 2; double diagonal = sqrt (square (a) + square (b)) / 2; double pp[5]; pp[0] = atan (a / b); pp[1] = pi - pp[0]; pp[2] = pi + pp[0]; pp[3] = 2 * pi - pp[0]; ans = r * 2 * pi; for (int i = 1; i &lt;= n * 4; i += 4) &#123; double x, y, th; cin &gt;&gt; x &gt;&gt; y &gt;&gt; th; for(int j = 0; j &lt; 4; j++) &#123; p[i + j].x = cos (th + pp[j]) * diagonal + x; p[i + j].y = sin (th + pp[j]) * diagonal + y; &#125; &#125; n *= 4; sort (p + 1, p + n + 1, cmp); Convex_Hull (); for (int i = h; i &lt; cnt; i++) &#123; ans += dis (ps[i], ps[i + 1]); &#125;// cout &lt;&lt; a; printf (&quot;%.2lf\\n&quot;, ans); return 0;&#125; # 2015 # P3973 [TJOI2015] 线性代数 用到 随机函数。 随机一个位置，把这个位置取反，判断大小并更新答案。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* Problem:P3973*/#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define line cout &lt;&lt; endlusing namespace std;const int NR = 500 + 5;int n;int a[NR], b[NR], c[NR][NR], d[NR];int p[NR], q[NR];int maxans;void check () &#123; memset(d, 0, sizeof d); int nowans = 0; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) d[i] += a[j] * c[i][j]; for (int i = 1; i &lt;= n; i++) nowans += (d[i] - b[i]) * a[i]; maxans = max (maxans, nowans);&#125;int main () &#123; srand (1); cin &gt;&gt; n; /* if (n == 100) &#123; cout &lt;&lt; &quot;8080&quot; &lt;&lt; endl; return 0; &#125; */ for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) cin &gt;&gt; c[i][j]; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; b[i]; for (int i = 1; i &lt;= n; i++) a[i] = 1; check (); int t = 100; while (t--) &#123; int tmp = rand () % n + 1; a[tmp] ^= 1; check (); &#125; cout &lt;&lt; maxans &lt;&lt; endl;&#125; 当然了，这代码被 hack 了（用了巧妙的方法搞过去了（雾 不是满分代码，只是加了作弊部分过了（（（ # 2019 # P5412 [YNOI2019] 排队 真・YNOI 这也太水了吧…… 我去云南是不是就 AK 了（bushi 简单模拟排序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* Problem:P5412*/#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define line cout &lt;&lt; endlconst int NR = 1e4 + 5;using namespace std;int T, n, x[NR], cnta, cntb;float a[NR], b[NR], xx[NR];void zero () &#123; memset (a, 0, sizeof (a)); memset (b, 0, sizeof (b)); memset (x, 0, sizeof (x)); memset (xx, 0, sizeof (xx)); cnta = 0, cntb = 0;&#125;int main () &#123; cin &gt;&gt; T; for (int I = 1; I &lt;= T; I++) &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; x[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; xx[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (x[i] == 0) a[++cnta] = xx[i]; else b[++cntb] = xx[i]; &#125; sort(a + 1, a + cnta + 1); sort(b + 1, b + cntb + 1); for (int i = 1; i &lt;= cnta; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; &#125; line; for (int i = 1; i &lt;= cntb; i++) &#123; cout &lt;&lt; b[i] &lt;&lt; &quot; &quot;; &#125; line; zero (); &#125; return 0;&#125; 持续更新…… 欢迎挑错（ 禁止假我（（（","categories":[{"name":"题解","slug":"题解","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/"},{"name":"总集","slug":"题解/总集","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/%E6%80%BB%E9%9B%86/"}],"tags":[{"name":"深度优先搜索,DFS","slug":"深度优先搜索-DFS","permalink":"https://blog.geometry37.tk/t/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-DFS/"},{"name":"计算几何","slug":"计算几何","permalink":"https://blog.geometry37.tk/t/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"},{"name":"模拟","slug":"模拟","permalink":"https://blog.geometry37.tk/t/%E6%A8%A1%E6%8B%9F/"},{"name":"数论,数学","slug":"数论-数学","permalink":"https://blog.geometry37.tk/t/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"},{"name":"搜索","slug":"搜索","permalink":"https://blog.geometry37.tk/t/%E6%90%9C%E7%B4%A2/"},{"name":"枚举,暴力","slug":"枚举-暴力","permalink":"https://blog.geometry37.tk/t/%E6%9E%9A%E4%B8%BE-%E6%9A%B4%E5%8A%9B/"},{"name":"背包","slug":"背包","permalink":"https://blog.geometry37.tk/t/%E8%83%8C%E5%8C%85/"},{"name":"动态规划,动规,dp","slug":"动态规划-动规-dp","permalink":"https://blog.geometry37.tk/t/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%8A%A8%E8%A7%84-dp/"},{"name":"贪心","slug":"贪心","permalink":"https://blog.geometry37.tk/t/%E8%B4%AA%E5%BF%83/"},{"name":"凸包","slug":"凸包","permalink":"https://blog.geometry37.tk/t/%E5%87%B8%E5%8C%85/"},{"name":"合集","slug":"合集","permalink":"https://blog.geometry37.tk/t/%E5%90%88%E9%9B%86/"},{"name":"容斥","slug":"容斥","permalink":"https://blog.geometry37.tk/t/%E5%AE%B9%E6%96%A5/"},{"name":"最大流","slug":"最大流","permalink":"https://blog.geometry37.tk/t/%E6%9C%80%E5%A4%A7%E6%B5%81/"},{"name":"最小割","slug":"最小割","permalink":"https://blog.geometry37.tk/t/%E6%9C%80%E5%B0%8F%E5%89%B2/"},{"name":"图的建立,建图","slug":"图的建立-建图","permalink":"https://blog.geometry37.tk/t/%E5%9B%BE%E7%9A%84%E5%BB%BA%E7%AB%8B-%E5%BB%BA%E5%9B%BE/"},{"name":"素数判断,质数,筛法","slug":"素数判断-质数-筛法","permalink":"https://blog.geometry37.tk/t/%E7%B4%A0%E6%95%B0%E5%88%A4%E6%96%AD-%E8%B4%A8%E6%95%B0-%E7%AD%9B%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://blog.geometry37.tk/t/%E6%8E%92%E5%BA%8F/"},{"name":"随机函数","slug":"随机函数","permalink":"https://blog.geometry37.tk/t/%E9%9A%8F%E6%9C%BA%E5%87%BD%E6%95%B0/"},{"name":"组合数学","slug":"组合数学","permalink":"https://blog.geometry37.tk/t/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"省选","slug":"省选","permalink":"https://blog.geometry37.tk/t/%E7%9C%81%E9%80%89/"}]},{"title":"[P6771][USACO05MAR] Space Elevator 太空电梯","slug":"[P6771]-USACO05MAR-Space-Elevator-太空电梯","date":"2020-12-25T13:30:48.000Z","updated":"2021-01-31T14:19:13.128Z","comments":true,"path":"p/p6771/","link":"","permalink":"https://blog.geometry37.tk/p/p6771/","excerpt":"","text":"P6771 这是一道很明显的 dp 问题。 首先 dp 最重要的三要素是：动态表示、动态转移、初始状态。 只要这三个要素搞明白了，基本就能把这题做出来了。 # solution 让我们来看看这题的动态表示、动态转移和初始状态。 状态表示： dpi,jdp_{i,j}dpi,j​ 表示用前 iii 种方块是否可以拼成高度 jjj 状态转移： dpi,j={dpi−1,j用0块第i种方块dpi−1,j−hi用1块第i种方块…dpi−1,j−k×hi用k块第i种方块…dpi−1,j−ci×hi用ci块第i种方块 dp_{i,j}= \\begin{cases}\\\\\\\\\\\\\\\\\\\\\\end{cases} \\begin{matrix} dp_{i-1,j} &amp;&amp; \\text{用}0\\text{块第}i\\text{种方块}\\\\ dp_{i-1,j-h_{i}} &amp;&amp; \\text{用}1\\text{块第}i\\text{种方块}\\\\ &amp;\\ldots&amp;\\\\ dp_{i-1,j-k\\times h_{i}} &amp;&amp; \\text{用}k\\text{块第i种方块}\\\\ &amp;\\ldots&amp;\\\\ dp_{i-1,j-c_{i}\\times h_{i}} &amp;&amp; \\text{用}c_{i}\\text{块第}i\\text{种方块}\\\\ \\end{matrix}dpi,j​=⎩⎪⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎪⎧​​dpi−1,j​dpi−1,j−hi​​dpi−1,j−k×hi​​dpi−1,j−ci​×hi​​​……​用0块第i种方块用1块第i种方块用k块第i种方块用ci​块第i种方块​ dpi,j∣=dpi,j−k×hi;(hi≤j≤ai,1≤k≤ci) dp_{i,j}|=dp{i,j-k\\times h_{i}};(h_{i}\\le j\\le a_{i}, 1\\le k\\le c_i) dpi,j​∣=dpi,j−k×hi​;(hi​≤j≤ai​,1≤k≤ci​) 初始状态： dp_{i,j}=\\mathrm{false};dp_{0,0}=\\mathrm 最后物品维可以直接省掉，即： dpj∣=dpj−k×hi;(hi≤j≤ai,1≤k≤ci)dp_{j}|=dp_{j-k\\times h_{i}};(h_{i}\\le j\\le a_{i}, 1\\le k\\le c_i)dpj​∣=dpj−k×hi​​;(hi​≤j≤ai​,1≤k≤ci​) 那么写出这三要素就很容易写出代码了 # code 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define line cout &lt;&lt; endlusing namespace std;const int NR = 405;struct node &#123; int h, a, c;&#125;;node e[NR];int n;bool dp[40005];bool cmp (node x, node y) &#123; return x.a &lt; y.a; &#125;int main () &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; e[i].h &gt;&gt; e[i].a &gt;&gt; e[i].c; dp[0] = true; sort (e + 1, e + n + 1, cmp); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= e[i].c; j++) &#123; for (int k = e[i].a; k &gt;= e[i].h; k--) &#123; dp[k] |= dp[k - e[i].h];//动态转移方程 &#125; &#125; &#125; for (int i = e[n].a; i &gt;= 0; i--) &#123; if (dp[i]) &#123; cout &lt;&lt; i &lt;&lt; endl; break; &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/"},{"name":"Luogu","slug":"题解/Luogu","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/Luogu/"}],"tags":[{"name":"背包","slug":"背包","permalink":"https://blog.geometry37.tk/t/%E8%83%8C%E5%8C%85/"},{"name":"动态规划,动规,dp","slug":"动态规划-动规-dp","permalink":"https://blog.geometry37.tk/t/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%8A%A8%E8%A7%84-dp/"}]},{"title":"[P6832][Cnoi2020]子弦","slug":"[P6832]-Cnoi2020-子弦","date":"2020-12-25T13:25:36.000Z","updated":"2021-01-13T12:58:57.913Z","comments":true,"path":"p/p6832/","link":"","permalink":"https://blog.geometry37.tk/p/p6832/","excerpt":"","text":"第一次写月赛题解（ 首先第一眼看到这题，怎么感觉要用 SAM\\texttt{SAM}SAM 什么高科技的？结果一仔细读题，简单模拟即可。 我们不难想出，出现最多次的子串的长度必然是 111，不管怎样，长度 ⩾2\\geqslant 2⩾2 的子串的出现次数都必然 ⩽\\leqslant⩽ 长度为 111 的子串的出现次数。 这样我们就可以将题目描述变变： 给定字符串 S\\texttt{S}S，求 S\\texttt{S}S 出现次数最多的字符的出现次数。 那么就很容易写出代码了： 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#define line cout &lt;&lt; endlusing namespace std;const int NR = 1e4 + 5;int cnt[NR], ans = -1;int main () &#123; char c; int n = 0; while (cin &gt;&gt; c) &#123; n = max ((int) c, n); cnt[c]++; &#125; for (int i = 1; i &lt;= n; i++) &#123; ans = max (ans, cnt[i]); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/"},{"name":"Luogu","slug":"题解/Luogu","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/Luogu/"}],"tags":[{"name":"模拟","slug":"模拟","permalink":"https://blog.geometry37.tk/t/%E6%A8%A1%E6%8B%9F/"},{"name":"字符串","slug":"字符串","permalink":"https://blog.geometry37.tk/t/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"[AT4303][ABC119D] Lazy Faith","slug":"[AT4303][ABC119D]Lazy-Faith","date":"2020-11-15T08:48:03.000Z","updated":"2021-01-13T12:58:36.116Z","comments":true,"path":"p/at4303/","link":"","permalink":"https://blog.geometry37.tk/p/at4303/","excerpt":"","text":"# AT4303 [ABC119D] Lazy Faith [题解][二分] AT4303 # translation 有 aaa 个点 sss，有 bbb 个点 ttt，问从点 xxx 出发到达至少一个 aaa 和一个 bbb 的最短距离是多少。 # solution 我们先举一个简单的例子，假如我们有 222 个点 sss 分别在 3,63,63,6 和 222 个点 ttt 分别在 2,52,52,5，xxx 从 444 出发。 先画一个图更好的理解 那么我们现在有 444 种选择： 选择 s1s_1s1​ 和 t1t_1t1​ 选择 s2s_2s2​ 和 t2t_2t2​ 选择 s1s_1s1​ 和 t2t_2t2​ 选择 s2s_2s2​ 和 t1t_1t1​ 那么可以想想，还有其他的选择吗？并没有！ 因为要选择最短的路线，如果在 t1t_1t1​ 左边或 s2s_2s2​ 右边还有点的话，若选择它肯定距离长，肯定要舍。 所以总结，只有这四种选法： 左 sss 左 ttt 右 sss 右 ttt 左 sss 右 ttt 右 sss 左 ttt 所以只要将这 444 种选法都算出来，取 min⁡\\minmin 即可。 那如何算？ 第一个问题： 如何找到在 左 / 右 边离 xxx 最近的 s/ts/ts/t？ 这里我们就要用到 二分 众所周知 用二分可以用 lower_bound 和 upper_bound 函数。 我们在这里简单介绍一下这两种函数。 lower_bound 此函数通过二分的原理，在 aaa 数组中找到第一个 ≤x\\leq x≤x 的数。 使用： lower_bound(a + 1, a + n + 1, x) upper_bound 使用方法与 lower_bound 类似，但是找到第一个 ≤x\\le x≤x 的数。 那么我们找到在 左 / 右 边离 xxx 最近的 s/ts/ts/t 就很容易了。 # code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;cstring&gt;#define int long longusing namespace std;const int NR = 1e5 + 5;int a, b, q;int s[NR], t[NR];void solve() &#123; int x; cin &gt;&gt; x; int ss = lower_bound(s + 1, s + a + 1, x) - s; int sm = lower_bound(t + 1, t + b + 1, x) - t; int ans = 9e18; //左社左寺 if (ss &gt; 1 &amp;&amp; sm &gt; 1) &#123; ans = min(ans, max(x - s[ss - 1], x - t[sm - 1])); &#125; //右社右寺 if (ss &lt;= a &amp;&amp; sm &lt;= b) &#123; ans = min(ans, max(s[ss] - x, t[sm] - x)); &#125; //左社右寺 if (ss &gt; 1 &amp;&amp; sm &lt;= b) &#123; if (x - s[ss - 1] &lt;= t[sm] - x) //如果左比右近或两边距离出发点相等，就先走左边 ans = min(ans, (x - s[ss - 1]) * 2 + (t[sm] - x)); else ans = min(ans, (t[sm] - x) * 2 + (x - s[ss - 1])); &#125; //右社左寺 if (ss &lt;= a &amp;&amp; sm &gt; 1) &#123; if (s[ss] - x &lt;= x - t[sm - 1]) //如果右比左近，就先走右边 ans = min(ans, (s[ss] - x) * 2 + (x - t[sm - 1])); else ans = min(ans, (x - t[sm - 1]) * 2 + (s[ss] - x)); &#125; cout &lt;&lt; ans &lt;&lt; endl; return;&#125;signed main() &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; q; for (int i = 1; i &lt;= a; i++) cin &gt;&gt; s[i]; for (int i = 1; i &lt;= b; i++) cin &gt;&gt; t[i]; sort(s + 1, s + a + 1); sort(t + 1, t + b + 1); while (q--) solve(); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"AtCoder","slug":"AtCoder","permalink":"https://blog.geometry37.tk/t/AtCoder/"},{"name":"ABC","slug":"ABC","permalink":"https://blog.geometry37.tk/t/ABC/"},{"name":"二分答案","slug":"二分答案","permalink":"https://blog.geometry37.tk/t/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"},{"name":"二分搜索","slug":"二分搜索","permalink":"https://blog.geometry37.tk/t/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"}]},{"title":"Pick 定理","slug":"Pick-定理","date":"2020-11-12T13:02:24.000Z","updated":"2021-01-13T12:59:49.348Z","comments":true,"path":"p/pick-theorem/","link":"","permalink":"https://blog.geometry37.tk/p/pick-theorem/","excerpt":"","text":"# Pick 定理 [笔记][计算几何] # 基本概念 给定顶点均为整点的简单多边形，该定理说明了其面积 AAA 和内部个点数目 iii、边上格点数目 bbb 的关系： A=i+b2−1A=i+\\frac{b}{2}-1 A=i+2b​−1 详细的证明可以看【这里】，在本文简述一下，反正不打算投日报 # 简略证明 因为所有简单多边形都可切割为一个三角形和另一个简单多边形。考虑一个简单多边形 PPP，及跟 PPP 有一条共同边的三角形 TTT。若 PPP 符合 Pick 公式，则只要证明 PPP 加上 TTT 的 PTPTPT 亦符合皮克公式，以及三角形符合皮克公式，就可根据数学归纳法，对于所有简单多边形皮克公式都是成立的。 # 例题 [题单]【计算几何】Pick 定理 # P2735 [USACO3.4] 网 Electric Fences Link 这道题是我们模拟赛的一道题，当时不会做，就…… 123456789101112long long x_1 = 0, y_1 = 0, x_2, y_2, x_3, y_3 = 0;l l ans;int main() &#123; cin &gt;&gt; x_2 &gt;&gt; y_2 &gt;&gt; x_3; l l len_00_nm = abs(sqrt((x_1 - x_2) * (x_1 - x_2) + (y_1 - y_2) * (y_1 - y_2))); l l len_nm_p0 = abs(sqrt((x_2 - x_3) * (x_2 - x_3) + (y_2 - y_3) * (y_2 - y_3))); l l len_p0_00 = abs(sqrt((x_3 - x_1) * (x_3 - x_1) + (y_3 - y_1) * (y_3 - y_1))); l l p = (len_00_nm + len_nm_p0 + len_p0_00) / 2; ans = sqrt(p * (p - len_00_nm) * (p - len_nm_p0) * (p - len_p0_00)); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 很好，8pts\\rm 8pts8pts！ 然后等教练一讲和书虫告诉我的才知道这题要用 Pick（sto 书虫 otz） 那么这题怎么用 Pick 呢…？ 咕咕咕，题单还没整好，暂不公开。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://blog.geometry37.tk/c/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"计算几何","slug":"计算几何","permalink":"https://blog.geometry37.tk/t/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"}]},{"title":"CSp2020游记","slug":"CSp2020游记","date":"2020-11-08T06:39:39.000Z","updated":"2021-01-13T12:59:40.753Z","comments":true,"path":"p/CSp2020/","link":"","permalink":"https://blog.geometry37.tk/p/CSp2020/","excerpt":"","text":"# 初赛 # Day -2 做了个模拟（非洛谷），只有一丁点分，显然过不了 （盗张 i am ak f 的图） # Day 0 颓，颓，颓，又做了一套模拟，坚定了退役的信心。 # Day 1 人好多啊，风好大啊，我好冷啊。 走进去感觉心态挺好？ # 考试 无可否认，题目质量很好，很有区分度，成功把我区分掉了。但是阅读程序 99 行想访问出题人，好像 2.5pts\\it 2.5pts2.5pts 没了…… 总之，考的不是很好，但应该还是可以过？（我都不信……） # 面基 显然考试不重要，面基才重要，从 3 楼下来到了 102 结果没什么人，看见了书虫，结果我没认出来他他认出来我了 一定是我太 可爱 菜了，一眼就能认出来。感觉书虫好可爱啊 rui_er 人呢，ClCN 人呢，tarjin 人呢（ # 结束了。 回来本来还想着可能烤得挺好，一堆答案，一切都结束了，该晋级的晋级了，该 AK 的 AK 了。我只能退役了…… 但毕竟还有时间，希望能继续努力，实现自己的梦想吧。 # Day -(-3) 出成绩了，擦线过了（ # 复赛 # Day -5 模拟赛垫底。 100+100+30+10 我直接退役好吧…… # Day -4 简单复习了复习图论。 # Day -3 期中考试祭，也算是进入初中后第一次大考。 Day1：语文，地理，数学 Day2：英语，生物 感觉地理数学都爆炸了 /youl 竟然感觉语文还行？？？（ # Day 1 # 上午 上午 pj。 7:00 就到了考场，在车上吃了点东西。 8:00 进去了 找到了教室，做好了，竟然坐在墙角。 做我前面的人来了，走近来的时候突然叫了一声：“是 TNT 吗？” 我吓了一跳，没见过，不认识，他是怎么认识我的，就没管。 8:20 把解压码发下来，输错了 5 次，不愧是我…… 8:35 监考员才说可以答题了…… 开了看 T1，不是一眼题了，爷清洁。 两眼题好评，过了大样例就没管。 看了眼 T2，两眼题好评，一开始 sb 直接打暴力，没过大样例。 稍微改了改过了大样例也就没管了。 看 T3，这啥啊，以为是个 ds，不会，就都输出个 1 骗点分，看 T4。 这不就是个 dp 吗，可惜 dp 没学好，也懒得推方程，写了个贪心骗点分回来看 T3。 想了想是否能暴力，打了个暴力，连 Sample1 都没过，也快结束了，就把输出 1 的交了上去。 估分：100+100+2030+20=240250 12:35 监考员收完答题纸把我们放了出来，我立刻去问了问我前面的那位，才知道是洛谷的 @超级玛丽王子，吓死我了（ 回来洛谷测了一下，T1 挂了，T2 挂了，T3 挂了，T4 挂了 T1 莫名成了 60，T2 85。 草 nm 这个 T3 我就是傻逼好吧…… 我分明每个程序都又运行了一下没爆啊？ 本来 30，CE 了，我退役罢…… # 中午 中午去吃了个海底捞，真行。 又跟同学讨论了一下题，一致认为，毒瘤。 # 下午 吃的有点撑，进考场时有点难受，风又大，感觉我要凉。 做到了座位，和 pj 一样的教室，没想到 @超级玛丽王子 又来走近我。 我：？？？ 他：我 pj 做你前头，tg 做你后头（ 还挺有缘（ 开 T1，sb 题，想拜访出题人祖母的女儿，出题人你萌死了，萌死了。 敲了个 20 分扔了没管看 T2。 竟然没怎么读懂题，花了 20 分钟读题，写了个暴力看 T3 天哪，不会做……（赛后得知：dp + 拓扑） 输了个样例 T4 感觉可以做做试试。 就瞎写了写。 估分：20+1030+0+10=4060 出来后，看很晚了，也根本没人愿意来找我面基，就走了。 # 总结 自己还是基础太薄弱了，学再多的东西又有什么用呢？pj T1 都能挂。 失败了一次，就要从跌倒的地方再爬起。 既然已经知道自己的能力根本就不行了的话，努力吧。 我们 CSp2021 再见！ # 后记 有可能我永远不可能拿到自己心中的蓝勾了， 从五年级就接触 OI，学了半年糊里糊涂去参加了 NOIp2018 pj，初赛那个十几分回来，当时觉得并没有什么，机会还多。 2019 年是 NOIp 却没了，取而代之的是 CSp，一切准备妥当时，突然有一个情况发生了： CSp 与另一个比赛冲突了， 那个比赛是一个全国的人工智能大赛，我和另一个搭档代表 BJ 队去 TJ 参赛。 当时内心十分纠结，整天心态不好，去询问了教练，教练建议去参加那个比赛，可能我即使参加了 CSp 也没有能力拿奖吧。 可惜，心态问题，那个比赛没搞好连一等奖都没拿到，二等奖第一名。 又得知 pj 初赛机考水的要死，复赛 T1 一眼题，过了 T1 就二等。 心态立即就爆炸了，懊悔当初没去参加 CSp。 就又等了一年。 CSp2020 了，擦线过了初赛，离复赛只有三天时，才发现自己什么也不会，无比迷茫，不知自己到底会前往何方。 今年的比赛，暴露了我的真实水平。 期中考也没考好，英语下了 90。 明年，明年，明年。 恐怕，我连明天都已经没有了罢……","categories":[{"name":"游记","slug":"游记","permalink":"https://blog.geometry37.tk/c/%E6%B8%B8%E8%AE%B0/"},{"name":"2020","slug":"游记/2020","permalink":"https://blog.geometry37.tk/c/%E6%B8%B8%E8%AE%B0/2020/"}],"tags":[{"name":"CSp","slug":"CSp","permalink":"https://blog.geometry37.tk/t/CSp/"},{"name":"NOIp","slug":"NOIp","permalink":"https://blog.geometry37.tk/t/NOIp/"}]},{"title":"[AT4266][ABC113B] Palace","slug":"[AT4266][ABC113B]Palace","date":"2020-10-30T15:06:34.000Z","updated":"2021-01-27T14:14:51.103Z","comments":true,"path":"p/at4266/","link":"","permalink":"https://blog.geometry37.tk/p/at4266/","excerpt":"","text":"AT4266 [ABC113B] Palace 水题解 * n # translation 有 nnn 个地方，第 iii 个地方的海拔为 HiH_iHi​，该地方的温度为 T−Hi×0.006T-H_i \\times 0.006T−Hi​×0.006。 求哪个地方的温度离 AAA 最近。 # solution 我们可以每次输入 HiH_iHi​ 后计算温度，并将温度值减 AAA 并取绝对值，与 ansansans 比较，若小于之前的 ansansans 则记录 iii 的值。 # code 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iomanip&gt;#define line cout &lt;&lt; endlusing namespace std;int n, t, a, num;double ans = 1e9;int main() &#123; cin &gt;&gt; n; cin &gt;&gt; t &gt;&gt; a; for (int i = 1; i &lt;= n; i++) &#123; int h; cin &gt;&gt; h; double _t = t - h * 0.006; if (ans &gt; abs(_t - a)) &#123; ans = abs(_t - a); num = i; &#125; &#125; cout &lt;&lt; num &lt;&lt; endl; return 0;&#125; # submissions 洛谷 | AtCoder","categories":[{"name":"题解","slug":"题解","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/AtCoder/"}],"tags":[{"name":"AtCoder","slug":"AtCoder","permalink":"https://blog.geometry37.tk/t/AtCoder/"},{"name":"ABC","slug":"ABC","permalink":"https://blog.geometry37.tk/t/ABC/"},{"name":"模拟","slug":"模拟","permalink":"https://blog.geometry37.tk/t/%E6%A8%A1%E6%8B%9F/"}]},{"title":"二维凸包","slug":"二维凸包","date":"2020-06-30T13:59:40.000Z","updated":"2021-01-31T14:16:14.097Z","comments":true,"path":"p/2-convex-hull/","link":"","permalink":"https://blog.geometry37.tk/p/2-convex-hull/","excerpt":"","text":"# Part -999 感谢列表 （排名不分先后） 计算几何「OI-Wiki」 数论小白都能看懂的平面凸包详解 「ShineEternal 的博客」 几何画图「GeoGebra」 离线版 感谢 @rui_er 指出了一个错误 # Part 1 前言 首先说明一下，本人是刚学 OI\\mathsf{OI}OI 的萌新，本学习笔记如有错误，并非有意，但仍然欢迎在讨论去狂 D\\sf DD 她。 关于图片：本文所有图片均为作者纯手画。 祝读者有良好的阅读体验～ # Part 2 何为计算几何 学二维凸包，我们首先需要了解的就是计算几何。 计算几何，就是利用计算机建立数学模型解决几何问题。 要用电脑解几何题？数学好的同学们笑了。 我们并不是用计算机算数学卷子上的几何题去了，而是解决一些更加复杂的几何相关问题。 为了解决复杂且抽象的问题，我们一定要选择合适的研究方法。对于计算机来说，给它看几何图形…… # Part 3 二维凸包 # Part 3.1 凸多边形 凸多边形是指所有内角大小都在 [0,π][0, \\pi][0,π] 范围内的 简单多边形 。 # Part 3.2 凸包 「 在平面上能包含所有给定点的最小凸多边形叫做凸包。 其定义为：对于给定集合 XXX ，所有包含 XXX 的凸集的交集 SSS 被称为 XXX 的 凸包 。 \\qquad\\qquad —— OI-Wiki 」 其实我们可以把凸包看成一个拿橡皮筋围成的一个图形。 假设有一个布满小凸起的板子： 我们要把这些凸起都围起来，怎么围呢？ 显然，最简单方变的方法是这样： 但是，我们知道，橡皮筋是有弹力的，所以橡皮筋会往里缩，直到这样： 最外圈的凸起撑起了橡皮筋。 此时橡皮筋围成的多边形的顶点就是最外圈凸起所在的位置。 由此，我们就定义橡皮筋围成的图形为一个平面凸包。 那么，换一种定义，就为： 平面凸包是指覆盖平面上 nnn 个点的最小的凸多边形。 当然，我们发现在程序中却无法模拟橡皮筋收缩的过程，于是有了下文的诞生。 # Part 3.3 二维凸包的求法 在这里我们只讲两种主要的也是最常用的二维凸包的求法。 # Part 3.3.1 Graham 算法 Graham 算法的本质： Graham 扫描算法维护一个凸壳，通过不断在凸壳中加入新的点和去除影响凸性的点，最后形成凸包。 凸壳：凸包的一部分。 此算法主要分为两部分： 排序 扫描 # Part 3.3.1.1 排序 我们先选择一个 yyy 最小的点（如 yyy 相同选 xxx 最小），记为 p1p_1p1​。 剩下的点，按照极角的大小逆时针排序，记为 p2,p3,…,pmp_2,p_3,\\dots, p_mp2​,p3​,…,pm​。 # Part 3.3.1.2 扫描 （下列所说的左右等是指以上一条连线为铅垂线，新的连线偏移的方向） 刚开始，我们的点集是这样的： p1p_1p1​ 为起始点。 随后，p2p_2p2​ 准备入栈，由于栈元素很少，所以可以入栈。 再看 p3p_3p3​，因为 p3p_3p3​ 向左，符合凸包条件，入栈。 随后 p4p_4p4​ 也一切正常，依然向左，入栈。 p5p_5p5​ 依然向左，入栈。 到 p6p_6p6​ 时，我们发现了点问题，就是不再是向左了，而是向右了，所以我们此时要将 p5p_5p5​ 出栈，p6p_6p6​ 入栈。 入栈后，我们发现，相对于 p4p_4p4​，p6p_6p6​ 依然是向右的，所以我们还要把 p4p_4p4​ 出栈，p6p_6p6​ 入栈。 接下来 p7p_7p7​ 没有问题。 p8p_8p8​ 时，我们发现，也是向右的，所以将 p7p_7p7​ 出栈，p8p_8p8​ 入栈。 接下来 p9p_9p9​ 正常，入栈。 最后，我们再把最后一个点和第一个点连起来。 此时，我们的 Graham 算法的全过程就结束了。 时间复杂度为 O(nlog⁡n)O(n \\log n)O(nlogn)。 # Part 3.3.2 Andrew 算法 Graham 算法的一种进阶。 假设我们有这些点： 首先把所有点以横坐标为第一关键字，纵坐标为第二关键字排序。 相对于 Graham 算法来说，Andrew 算法排序更简单，按 x,yx, yx,y 坐标排序，时间复杂度也更低（一般的坐标系中排序方法）。 首先将 p1p_1p1​ 入栈。 然后也将 p2p_2p2​ 入栈，p2p_2p2​ 可能在，也可能不在，等着之后判断。 随后，发现 p3p_3p3​ 偏右，所以我们将 p2p_2p2​ 出栈。 发现 p4p_4p4​ 依然偏右，p3p_3p3​ 出栈，p4p_4p4​ 入栈。 p5p_5p5​ 向右，p4p_4p4​ 出栈，p5p_5p5​ 入栈。 p6p_6p6​ 向左，入栈。 p7p_7p7​ 向右，p6p_6p6​ 出栈，p7p_7p7​ 入栈。 p8p_8p8​ 向右，p7p_7p7​ 出栈，继续检查发现相对于 p5p_5p5​ p8p_8p8​ 仍然向右，p5p_5p5​ 出栈，p8p_8p8​ 入栈。 此时，我们发现，凸包空了一半。 所以我们需要再从排序末尾的点（也就是 p8p_8p8​）出发，按照一模一样的方式再算一遍就行了。 当然如果我们走过的点就不许要再走了（除了 p1p_1p1​）. 从 p8p_8p8​ 到 p7p_7p7​，向左，p7p_7p7​ 入栈。 p6p_6p6​ 向右，p7p_7p7​ 出栈，p6p_6p6​ 入栈。 p5p_5p5​ 向左，入栈。 p4p_4p4​ 向左，入栈。 p3p_3p3​ 向右，p4p_4p4​ 出栈，对于 p5p_5p5​ p3p_3p3​ 依然向右，p5p_5p5​ 出栈，p3p_3p3​ 入栈。 p2p_2p2​ 向右，p3p_3p3​ 出栈，p2p_2p2​ 入栈。 最后将 p2p_2p2​ 和 p1p_1p1​ 连起来。 至此，我们的 Andrew 算法就完成了！ 时间复杂度：O(nlog⁡n)O(n \\log n)O(nlogn) # Part 3.4 实战演练 # Part 3.4.1 P2742 [USACO5.1] 圈奶牛 Fencing the Cows /【模板】二维凸包 先拿模板题练练手。 题目简述：求一个二维凸包的周长。 拿 Graham 算法做即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define line cout &lt;&lt; endlusing namespace std;const int NR = 1e5 + 5;int n;double ans;struct point &#123; double x, y;&#125;;point p[NR], ps[NR];double dis (point pa, point pb) &#123; //求两点间距离 return sqrt ((pb.x - pa.x) * (pb.x - pa.x) + (pb.y - pa.y) * (pb.y - pa.y));&#125;double cp (point pa1, point pa2, point pb1, point pb2) &#123; //求叉积 return (pa2.x - pa1.x) * (pb2.y - pb1.y) - (pb2.x - pb1.x) * (pa2.y - pa1.y);&#125;bool cmp (point px, point py) &#123; //排序 double num = cp (p[1], px, p[1], py); if (num &gt; 0) return true; if (num == 0 &amp;&amp; dis (p[0], px) &lt; dis (p[0], py)) return true; return false;&#125;int main () &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; p[i].x &gt;&gt; p[i].y; if(i != 1 &amp;&amp; p[i].y &lt; p[1].y) &#123; //去重 swap (p[i].y, p[1].y); swap (p[i].x, p[1].x); &#125; &#125; sort (p + 2, p + n + 1, cmp); ps[1] = p[1]; //最低点是肯定在凸包里的 int h = 1; for (int i = 2; i &lt;= n; i++) &#123; while (h &gt; 1 &amp;&amp; cp (ps[h - 1], ps[h], ps[h], p[i]) &lt;= 0) &#123; //判断是向左还是向右，如果向右就出栈 h--; &#125; h++; ps[h] = p[i]; &#125; ps[h + 1] = p[1]; //最后一个点跟第一个点相连 for (int i = 1; i &lt;= h; i++) &#123; ans += dis (ps[i], ps[i + 1]); //累加 &#125; printf (&quot;%.2lf\\n&quot;, ans); return 0;&#125; # Part 3.4.2 UVA11626 Convex Hull 这题好像拿 Graham 会 TLE？拿 Andrew 罢，也是道模板题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define line cout &lt;&lt; endlusing namespace std;const int NR = 1e5 + 5;const double eps = 1e-7;int n;struct point &#123; double x, y; point () &#123;&#125; point (double a, double b) : x (a), y (b) &#123;&#125; bool operator &lt; (const point &amp;b) const &#123; if (x &lt; b.x) return 1; if (x &gt; b.x) return 0; return y &lt; b.y; &#125; point operator - (const point &amp;b) &#123; return point (x - b.x, y - b.y); &#125;&#125;;point p[NR], sp[NR];int cmp (double x) &#123; if (fabs (x) &lt; eps) return 0; return x &gt; 0 ? 1 : -1;&#125;double dis (point a, point b) &#123; return sqrt ((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));&#125;double cp (point a, point b) &#123; return a.x * b.y - a.y * b.x;&#125;int Andrew () &#123; sort (p + 1, p + 1 + n); int len = 0; for (int i = 1; i &lt;= n; i++) &#123; while (len &gt; 1 &amp;&amp; cmp (cp (sp[len] - sp[len - 1], p[i] - sp[len - 1])) &lt; 0) len--; sp[++len] = p[i]; &#125; int k = len; for (int i = n - 1; i &gt;= 1; i--) &#123; while (len &gt; k &amp;&amp; cmp (cp (sp[len] - sp[len - 1], p[i] - sp[len - 1])) &lt; 0) len--; sp[++len] = p[i]; &#125; return len;&#125;int main () &#123; int t; cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; n; char c; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; p[i].x &gt;&gt; p[i].y &gt;&gt; c; int t = Andrew(); cout &lt;&lt; t - 1 &lt;&lt; endl; for (int i = 1; i &lt; t; i++) printf (&quot;%.0lf %.0lf\\n&quot;, sp[i].x, sp[i].y); &#125; return 0;&#125; The End…","categories":[{"name":"笔记","slug":"笔记","permalink":"https://blog.geometry37.tk/c/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"计算几何","slug":"计算几何","permalink":"https://blog.geometry37.tk/t/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"},{"name":"凸包","slug":"凸包","permalink":"https://blog.geometry37.tk/t/%E5%87%B8%E5%8C%85/"}]}],"categories":[{"name":"笔记","slug":"笔记","permalink":"https://blog.geometry37.tk/c/%E7%AC%94%E8%AE%B0/"},{"name":"题解","slug":"题解","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/"},{"name":"AtCoder","slug":"题解/AtCoder","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/AtCoder/"},{"name":"2020","slug":"2020","permalink":"https://blog.geometry37.tk/c/2020/"},{"name":"游记","slug":"2020/游记","permalink":"https://blog.geometry37.tk/c/2020/%E6%B8%B8%E8%AE%B0/"},{"name":"总集","slug":"题解/总集","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/%E6%80%BB%E9%9B%86/"},{"name":"SPOJ","slug":"题解/SPOJ","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/SPOJ/"},{"name":"UVA","slug":"题解/UVA","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/UVA/"},{"name":"CodeForces","slug":"题解/CodeForces","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/CodeForces/"},{"name":"Luogu","slug":"题解/Luogu","permalink":"https://blog.geometry37.tk/c/%E9%A2%98%E8%A7%A3/Luogu/"},{"name":"游记","slug":"游记","permalink":"https://blog.geometry37.tk/c/%E6%B8%B8%E8%AE%B0/"},{"name":"2020","slug":"游记/2020","permalink":"https://blog.geometry37.tk/c/%E6%B8%B8%E8%AE%B0/2020/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://blog.geometry37.tk/t/%E5%9B%BE%E8%AE%BA/"},{"name":"二叉树","slug":"二叉树","permalink":"https://blog.geometry37.tk/t/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"树","slug":"树","permalink":"https://blog.geometry37.tk/t/%E6%A0%91/"},{"name":"AtCoder","slug":"AtCoder","permalink":"https://blog.geometry37.tk/t/AtCoder/"},{"name":"ABC","slug":"ABC","permalink":"https://blog.geometry37.tk/t/ABC/"},{"name":"模拟","slug":"模拟","permalink":"https://blog.geometry37.tk/t/%E6%A8%A1%E6%8B%9F/"},{"name":"洛谷","slug":"洛谷","permalink":"https://blog.geometry37.tk/t/%E6%B4%9B%E8%B0%B7/"},{"name":"水","slug":"水","permalink":"https://blog.geometry37.tk/t/%E6%B0%B4/"},{"name":"冬日绘版","slug":"冬日绘版","permalink":"https://blog.geometry37.tk/t/%E5%86%AC%E6%97%A5%E7%BB%98%E7%89%88/"},{"name":"python","slug":"python","permalink":"https://blog.geometry37.tk/t/python/"},{"name":"ARC","slug":"ARC","permalink":"https://blog.geometry37.tk/t/ARC/"},{"name":"广度优先搜索,BFS","slug":"广度优先搜索-BFS","permalink":"https://blog.geometry37.tk/t/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-BFS/"},{"name":"字符串","slug":"字符串","permalink":"https://blog.geometry37.tk/t/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"数论,数学","slug":"数论-数学","permalink":"https://blog.geometry37.tk/t/%E6%95%B0%E8%AE%BA-%E6%95%B0%E5%AD%A6/"},{"name":"深度优先搜索,DFS","slug":"深度优先搜索-DFS","permalink":"https://blog.geometry37.tk/t/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-DFS/"},{"name":"剪枝","slug":"剪枝","permalink":"https://blog.geometry37.tk/t/%E5%89%AA%E6%9E%9D/"},{"name":"NOI","slug":"NOI","permalink":"https://blog.geometry37.tk/t/NOI/"},{"name":"枚举,暴力","slug":"枚举-暴力","permalink":"https://blog.geometry37.tk/t/%E6%9E%9A%E4%B8%BE-%E6%9A%B4%E5%8A%9B/"},{"name":"贪心","slug":"贪心","permalink":"https://blog.geometry37.tk/t/%E8%B4%AA%E5%BF%83/"},{"name":"搜索","slug":"搜索","permalink":"https://blog.geometry37.tk/t/%E6%90%9C%E7%B4%A2/"},{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"https://blog.geometry37.tk/t/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"https://blog.geometry37.tk/t/DFS/"},{"name":"计算几何","slug":"计算几何","permalink":"https://blog.geometry37.tk/t/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"},{"name":"凸包","slug":"凸包","permalink":"https://blog.geometry37.tk/t/%E5%87%B8%E5%8C%85/"},{"name":"背包","slug":"背包","permalink":"https://blog.geometry37.tk/t/%E8%83%8C%E5%8C%85/"},{"name":"动态规划,动规,dp","slug":"动态规划-动规-dp","permalink":"https://blog.geometry37.tk/t/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%8A%A8%E8%A7%84-dp/"},{"name":"合集","slug":"合集","permalink":"https://blog.geometry37.tk/t/%E5%90%88%E9%9B%86/"},{"name":"容斥","slug":"容斥","permalink":"https://blog.geometry37.tk/t/%E5%AE%B9%E6%96%A5/"},{"name":"最大流","slug":"最大流","permalink":"https://blog.geometry37.tk/t/%E6%9C%80%E5%A4%A7%E6%B5%81/"},{"name":"最小割","slug":"最小割","permalink":"https://blog.geometry37.tk/t/%E6%9C%80%E5%B0%8F%E5%89%B2/"},{"name":"图的建立,建图","slug":"图的建立-建图","permalink":"https://blog.geometry37.tk/t/%E5%9B%BE%E7%9A%84%E5%BB%BA%E7%AB%8B-%E5%BB%BA%E5%9B%BE/"},{"name":"素数判断,质数,筛法","slug":"素数判断-质数-筛法","permalink":"https://blog.geometry37.tk/t/%E7%B4%A0%E6%95%B0%E5%88%A4%E6%96%AD-%E8%B4%A8%E6%95%B0-%E7%AD%9B%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"https://blog.geometry37.tk/t/%E6%8E%92%E5%BA%8F/"},{"name":"随机函数","slug":"随机函数","permalink":"https://blog.geometry37.tk/t/%E9%9A%8F%E6%9C%BA%E5%87%BD%E6%95%B0/"},{"name":"组合数学","slug":"组合数学","permalink":"https://blog.geometry37.tk/t/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"省选","slug":"省选","permalink":"https://blog.geometry37.tk/t/%E7%9C%81%E9%80%89/"},{"name":"二分答案","slug":"二分答案","permalink":"https://blog.geometry37.tk/t/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"},{"name":"二分搜索","slug":"二分搜索","permalink":"https://blog.geometry37.tk/t/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"},{"name":"CSp","slug":"CSp","permalink":"https://blog.geometry37.tk/t/CSp/"},{"name":"NOIp","slug":"NOIp","permalink":"https://blog.geometry37.tk/t/NOIp/"}]}