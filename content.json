{"meta":{"title":"Sdntrotyl's Meadow","subtitle":"","description":"","author":"Sdntrotyl","url":"https://www.tsd-blog.tk","root":"/"},"pages":[{"title":"categories","date":"2020-12-19T02:09:29.000Z","updated":"2020-12-19T02:10:07.464Z","comments":true,"path":"categories/index.html","permalink":"https://www.tsd-blog.tk/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-12-19T02:09:38.000Z","updated":"2020-12-19T02:10:11.142Z","comments":true,"path":"tags/index.html","permalink":"https://www.tsd-blog.tk/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"【题解】[AT4303][ABC119D] Lazy Faith","slug":"【题解】-AT4303-ABC119D-Lazy-Faith","date":"2020-11-15T08:48:03.000Z","updated":"2020-12-18T13:07:36.923Z","comments":true,"path":"2020/11/15/【题解】-AT4303-ABC119D-Lazy-Faith/","link":"","permalink":"https://www.tsd-blog.tk/2020/11/15/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91-AT4303-ABC119D-Lazy-Faith/","excerpt":"","text":"# AT4303 [ABC119D] Lazy Faith [题解][二分] AT4303 # translation 有 aaa 个点 sss，有 bbb 个点 ttt，问从点 xxx 出发到达至少一个 aaa 和一个 bbb 的最短距离是多少。 # solution 我们先举一个简单的例子，假如我们有 222 个点 sss 分别在 3,63,63,6 和 222 个点 ttt 分别在 2,52,52,5，xxx 从 444 出发。 先画一个图更好的理解 那么我们现在有 444 种选择： 选择 s1s_1s1​ 和 t1t_1t1​ 选择 s2s_2s2​ 和 t2t_2t2​ 选择 s1s_1s1​ 和 t2t_2t2​ 选择 s2s_2s2​ 和 t1t_1t1​ 那么可以想想，还有其他的选择吗？并没有！ 因为要选择最短的路线，如果在 t1t_1t1​ 左边或 s2s_2s2​ 右边还有点的话，若选择它肯定距离长，肯定要舍。 所以总结，只有这四种选法： 左 sss 左 ttt 右 sss 右 ttt 左 sss 右 ttt 右 sss 左 ttt 所以只要将这 444 种选法都算出来，取 min⁡\\minmin 即可。 那如何算？ 第一个问题： 如何找到在 左 / 右 边离 xxx 最近的 s/ts/ts/t？ 这里我们就要用到 二分 众所周知 用二分可以用 lower_bound 和 upper_bound 函数。 我们在这里简单介绍一下这两种函数。 lower_bound 此函数通过二分的原理，在 aaa 数组中找到第一个 ≤x\\leq x≤x 的数。 使用： lower_bound(a + 1, a + n + 1, x) upper_bound 使用方法与 lower_bound 类似，但是找到第一个 ≤x\\le x≤x 的数。 那么我们找到在 左 / 右 边离 xxx 最近的 s/ts/ts/t 就很容易了。 # code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;cstring&gt;#define int long longusing namespace std;const int NR = 1e5 + 5;int a, b, q;int s[NR], t[NR];void solve() &#123; int x; cin &gt;&gt; x; int ss = lower_bound(s + 1, s + a + 1, x) - s; int sm = lower_bound(t + 1, t + b + 1, x) - t; int ans = 9e18; //左社左寺 if (ss &gt; 1 &amp;&amp; sm &gt; 1) &#123; ans = min(ans, max(x - s[ss - 1], x - t[sm - 1])); &#125; //右社右寺 if (ss &lt;= a &amp;&amp; sm &lt;= b) &#123; ans = min(ans, max(s[ss] - x, t[sm] - x)); &#125; //左社右寺 if (ss &gt; 1 &amp;&amp; sm &lt;= b) &#123; if (x - s[ss - 1] &lt;= t[sm] - x) //如果左比右近或两边距离出发点相等，就先走左边 ans = min(ans, (x - s[ss - 1]) * 2 + (t[sm] - x)); else ans = min(ans, (t[sm] - x) * 2 + (x - s[ss - 1])); &#125; //右社左寺 if (ss &lt;= a &amp;&amp; sm &gt; 1) &#123; if (s[ss] - x &lt;= x - t[sm - 1]) //如果右比左近，就先走右边 ans = min(ans, (s[ss] - x) * 2 + (x - t[sm - 1])); else ans = min(ans, (x - t[sm - 1]) * 2 + (s[ss] - x)); &#125; cout &lt;&lt; ans &lt;&lt; endl; return;&#125;signed main() &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; q; for (int i = 1; i &lt;= a; i++) cin &gt;&gt; s[i]; for (int i = 1; i &lt;= b; i++) cin &gt;&gt; t[i]; sort(s + 1, s + a + 1); sort(t + 1, t + b + 1); while (q--) solve(); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://www.tsd-blog.tk/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"AtCoder","slug":"AtCoder","permalink":"https://www.tsd-blog.tk/tags/AtCoder/"},{"name":"ABC","slug":"ABC","permalink":"https://www.tsd-blog.tk/tags/ABC/"},{"name":"二分答案","slug":"二分答案","permalink":"https://www.tsd-blog.tk/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"},{"name":"二分搜索","slug":"二分搜索","permalink":"https://www.tsd-blog.tk/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"}]},{"title":"【笔记】Pick 定理","slug":"【笔记】Pick-定理","date":"2020-11-12T13:02:24.000Z","updated":"2020-12-18T13:39:13.531Z","comments":true,"path":"2020/11/12/【笔记】Pick-定理/","link":"","permalink":"https://www.tsd-blog.tk/2020/11/12/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91Pick-%E5%AE%9A%E7%90%86/","excerpt":"","text":"console.error(\"Error: [hexo-tag-aplayer] Meting support is disabled, cannot resolve the meting tags properly.\"); # Pick 定理 [笔记][计算几何] # 基本概念 给定顶点均为整点的简单多边形，该定理说明了其面积 AAA 和内部个点数目 iii、边上格点数目 bbb 的关系： A=i+b2−1A=i+\\frac{b}{2}-1 A=i+2b​−1 详细的证明可以看【这里】，在本文简述一下，反正不打算投日报 # 简略证明 因为所有简单多边形都可切割为一个三角形和另一个简单多边形。考虑一个简单多边形 PPP，及跟 PPP 有一条共同边的三角形 TTT。若 PPP 符合 Pick 公式，则只要证明 PPP 加上 TTT 的 PTPTPT 亦符合皮克公式，以及三角形符合皮克公式，就可根据数学归纳法，对于所有简单多边形皮克公式都是成立的。 # 例题 [题单]【计算几何】Pick 定理 # P2735 [USACO3.4] 网 Electric Fences Link 这道题是我们模拟赛的一道题，当时不会做，就…… 123456789101112long long x_1 = 0, y_1 = 0, x_2, y_2, x_3, y_3 = 0;l l ans;int main() &#123; cin &gt;&gt; x_2 &gt;&gt; y_2 &gt;&gt; x_3; l l len_00_nm = abs(sqrt((x_1 - x_2) * (x_1 - x_2) + (y_1 - y_2) * (y_1 - y_2))); l l len_nm_p0 = abs(sqrt((x_2 - x_3) * (x_2 - x_3) + (y_2 - y_3) * (y_2 - y_3))); l l len_p0_00 = abs(sqrt((x_3 - x_1) * (x_3 - x_1) + (y_3 - y_1) * (y_3 - y_1))); l l p = (len_00_nm + len_nm_p0 + len_p0_00) / 2; ans = sqrt(p * (p - len_00_nm) * (p - len_nm_p0) * (p - len_p0_00)); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 很好，8pts\\rm 8pts8pts！ 然后等教练一讲和书虫告诉我的才知道这题要用 Pick（sto 书虫 otz） 那么这题怎么用 Pick 呢…？ 咕咕咕，题单还没整好，暂不公开。","categories":[{"name":"笔记","slug":"笔记","permalink":"https://www.tsd-blog.tk/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"计算几何","slug":"计算几何","permalink":"https://www.tsd-blog.tk/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"}]},{"title":"【游记】CSp2020","slug":"【游记】CSp2020-1","date":"2020-11-08T06:39:39.000Z","updated":"2020-12-18T13:07:44.959Z","comments":true,"path":"2020/11/08/【游记】CSp2020-1/","link":"","permalink":"https://www.tsd-blog.tk/2020/11/08/%E3%80%90%E6%B8%B8%E8%AE%B0%E3%80%91CSp2020-1/","excerpt":"","text":"# 初赛 # Day -2 做了个模拟（非洛谷），只有一丁点分，显然过不了 （盗张 i am ak f 的图） # Day 0 颓，颓，颓，又做了一套模拟，坚定了退役的信心。 # Day 1 人好多啊，风好大啊，我好冷啊。 走进去感觉心态挺好？ # 考试 无可否认，题目质量很好，很有区分度，成功把我区分掉了。但是阅读程序 99 行想访问出题人，好像 2.5pts\\it 2.5pts2.5pts 没了…… 总之，考的不是很好，但应该还是可以过？（我都不信……） # 面基 显然考试不重要，面基才重要，从 3 楼下来到了 102 结果没什么人，看见了书虫，结果我没认出来他他认出来我了 一定是我太 可爱 菜了，一眼就能认出来。感觉书虫好可爱啊 rui_er 人呢，ClCN 人呢，tarjin 人呢（ # 结束了。 回来本来还想着可能烤得挺好，一堆答案，一切都结束了，该晋级的晋级了，该 AK 的 AK 了。我只能退役了…… 但毕竟还有时间，希望能继续努力，实现自己的梦想吧。 # Day -(-3) 出成绩了，擦线过了（ # 复赛 # Day -5 模拟赛垫底。 100+100+30+10 我直接退役好吧…… # Day -4 简单复习了复习图论。 # Day -3 期中考试祭，也算是进入初中后第一次大考。 Day1：语文，地理，数学 Day2：英语，生物 感觉地理数学都爆炸了 /youl 竟然感觉语文还行？？？（ # Day 1 # 上午 上午 pj。 7:00 就到了考场，在车上吃了点东西。 8:00 进去了 找到了教室，做好了，竟然坐在墙角。 做我前面的人来了，走近来的时候突然叫了一声：“是 TNT 吗？” 我吓了一跳，没见过，不认识，他是怎么认识我的，就没管。 8:20 把解压码发下来，输错了 5 次，不愧是我…… 8:35 监考员才说可以答题了…… 开了看 T1，不是一眼题了，爷清洁。 两眼题好评，过了大样例就没管。 看了眼 T2，两眼题好评，一开始 sb 直接打暴力，没过大样例。 稍微改了改过了大样例也就没管了。 看 T3，这啥啊，以为是个 ds，不会，就都输出个 1 骗点分，看 T4。 这不就是个 dp 吗，可惜 dp 没学好，也懒得推方程，写了个贪心骗点分回来看 T3。 想了想是否能暴力，打了个暴力，连 Sample1 都没过，也快结束了，就把输出 1 的交了上去。 估分：100+100+2030+20=240250 12:35 监考员收完答题纸把我们放了出来，我立刻去问了问我前面的那位，才知道是洛谷的 @超级玛丽王子，吓死我了（ 回来洛谷测了一下，T1 挂了，T2 挂了，T3 挂了，T4 挂了 T1 莫名成了 60，T2 85。 草 nm 这个 T3 我就是傻逼好吧…… 我分明每个程序都又运行了一下没爆啊？ 本来 30，CE 了，我退役罢…… # 中午 中午去吃了个海底捞，真行。 又跟同学讨论了一下题，一致认为，毒瘤。 # 下午 吃的有点撑，进考场时有点难受，风又大，感觉我要凉。 做到了座位，和 pj 一样的教室，没想到 @超级玛丽王子 又来走近我。 我：？？？ 他：我 pj 做你前头，tg 做你后头（ 还挺有缘（ 开 T1，sb 题，想拜访出题人祖母的女儿，出题人你萌死了，萌死了。 敲了个 20 分扔了没管看 T2。 竟然没怎么读懂题，花了 20 分钟读题，写了个暴力看 T3 天哪，不会做……（赛后得知：dp + 拓扑） 输了个样例 T4 感觉可以做做试试。 就瞎写了写。 估分：20+1030+0+10=4060 出来后，看很晚了，也根本没人愿意来找我面基，就走了。 # 总结 自己还是基础太薄弱了，学再多的东西又有什么用呢？pj T1 都能挂。 失败了一次，就要从跌倒的地方再爬起。 既然已经知道自己的能力根本就不行了的话，努力吧。 我们 CSp2021 再见！ # 后记 有可能我永远不可能拿到自己心中的蓝勾了， 从五年级就接触 OI，学了半年糊里糊涂去参加了 NOIp2018 pj，初赛那个十几分回来，当时觉得并没有什么，机会还多。 2019 年是 NOIp 却没了，取而代之的是 CSp，一切准备妥当时，突然有一个情况发生了： CSp 与另一个比赛冲突了， 那个比赛是一个全国的人工智能大赛，我和另一个搭档代表 BJ 队去 TJ 参赛。 当时内心十分纠结，整天心态不好，去询问了教练，教练建议去参加那个比赛，可能我即使参加了 CSp 也没有能力拿奖吧。 可惜，心态问题，那个比赛没搞好连一等奖都没拿到，二等奖第一名。 又得知 pj 初赛机考水的要死，复赛 T1 一眼题，过了 T1 就二等。 心态立即就爆炸了，懊悔当初没去参加 CSp。 就又等了一年。 CSp2020 了，擦线过了初赛，离复赛只有三天时，才发现自己什么也不会，无比迷茫，不知自己到底会前往何方。 今年的比赛，暴露了我的真实水平。 期中考也没考好，英语下了 90。 明年，明年，明年。 恐怕，我连明天都已经没有了罢……","categories":[{"name":"游记","slug":"游记","permalink":"https://www.tsd-blog.tk/categories/%E6%B8%B8%E8%AE%B0/"}],"tags":[{"name":"2020","slug":"2020","permalink":"https://www.tsd-blog.tk/tags/2020/"},{"name":"CSp","slug":"CSp","permalink":"https://www.tsd-blog.tk/tags/CSp/"},{"name":"NOIp","slug":"NOIp","permalink":"https://www.tsd-blog.tk/tags/NOIp/"}]},{"title":"【题解】[AT4266][ABC113B] Palace","slug":"【题解】-AT4266-ABC113B-Palace","date":"2020-10-30T15:06:34.000Z","updated":"2020-12-17T14:25:33.898Z","comments":true,"path":"2020/10/30/【题解】-AT4266-ABC113B-Palace/","link":"","permalink":"https://www.tsd-blog.tk/2020/10/30/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91-AT4266-ABC113B-Palace/","excerpt":"","text":"AT4266 [ABC113B] Palace 水题解 * n # translation 有 nnn 个地方，第 iii 个地方的海拔为 HiH_iHi​，该地方的温度为 T−Hi×0.006T-H_i \\times 0.006T−Hi​×0.006。 求哪个地方的温度离 AAA 最近。 # solution 我们可以每次输入 HiH_iHi​ 后计算温度，并将温度值减 AAA 并取绝对值，与 ansansans 比较，若小于之前的 ansansans 则记录 iii 的值。 # code 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iomanip&gt;#define line cout &lt;&lt; endlusing namespace std;int n, t, a, num;double ans = 1e9;int main() &#123; cin &gt;&gt; n; cin &gt;&gt; t &gt;&gt; a; for (int i = 1; i &lt;= n; i++) &#123; int h; cin &gt;&gt; h; double _t = t - h * 0.006; if (ans &gt; abs(_t - a)) &#123; ans = abs(_t - a); num = i; &#125; &#125; cout &lt;&lt; num &lt;&lt; endl; return 0;&#125; # submissions 洛谷 | AtCoder","categories":[{"name":"题解","slug":"题解","permalink":"https://www.tsd-blog.tk/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"AtCoder","slug":"AtCoder","permalink":"https://www.tsd-blog.tk/tags/AtCoder/"},{"name":"ABC","slug":"ABC","permalink":"https://www.tsd-blog.tk/tags/ABC/"},{"name":"模拟","slug":"模拟","permalink":"https://www.tsd-blog.tk/tags/%E6%A8%A1%E6%8B%9F/"}]},{"title":"【笔记】二维凸包","slug":"【笔记】二维凸包","date":"2020-06-30T13:59:40.000Z","updated":"2020-12-18T13:07:27.700Z","comments":true,"path":"2020/06/30/【笔记】二维凸包/","link":"","permalink":"https://www.tsd-blog.tk/2020/06/30/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E4%BA%8C%E7%BB%B4%E5%87%B8%E5%8C%85/","excerpt":"","text":"# Part -999 感谢列表 （排名不分先后） 计算几何「OI-Wiki」 数论小白都能看懂的平面凸包详解 「ShineEternal 的博客」 几何画图「GeoGebra」 离线版 感谢 @rui_er 指出了一个错误 # Part 1 前言 首先说明一下，本人是刚学 OI\\mathsf{OI}OI 的萌新，本学习笔记如有错误，并非有意，但仍然欢迎在讨论去狂 D\\sf DD 她。 关于图片：本文所有图片均为作者纯手画。 祝读者有良好的阅读体验～ # Part 2 何为计算几何 学二维凸包，我们首先需要了解的就是计算几何。 计算几何，就是利用计算机建立数学模型解决几何问题。 要用电脑解几何题？数学好的同学们笑了。 我们并不是用计算机算数学卷子上的几何题去了，而是解决一些更加复杂的几何相关问题。 为了解决复杂且抽象的问题，我们一定要选择合适的研究方法。对于计算机来说，给它看几何图形…… # Part 3 二维凸包 # Part 3.1 凸多边形 凸多边形是指所有内角大小都在 [0,π][0, \\pi][0,π] 范围内的 简单多边形 。 # Part 3.2 凸包 「 在平面上能包含所有给定点的最小凸多边形叫做凸包。 其定义为：对于给定集合 XXX ，所有包含 XXX 的凸集的交集 SSS 被称为 XXX 的 凸包 。 \\qquad\\qquad —— OI-Wiki 」 其实我们可以把凸包看成一个拿橡皮筋围成的一个图形。 假设有一个布满小凸起的板子： 我们要把这些凸起都围起来，怎么围呢？ 显然，最简单方变的方法是这样： 但是，我们知道，橡皮筋是有弹力的，所以橡皮筋会往里缩，直到这样： 最外圈的凸起撑起了橡皮筋。 此时橡皮筋围成的多边形的顶点就是最外圈凸起所在的位置。 由此，我们就定义橡皮筋围成的图形为一个平面凸包。 那么，换一种定义，就为： 平面凸包是指覆盖平面上 nnn 个点的最小的凸多边形。 当然，我们发现在程序中却无法模拟橡皮筋收缩的过程，于是有了下文的诞生。 # Part 3.3 二维凸包的求法 在这里我们只讲两种主要的也是最常用的二维凸包的求法。 # Part 3.3.1 Graham 算法 Graham 算法的本质： Graham 扫描算法维护一个凸壳，通过不断在凸壳中加入新的点和去除影响凸性的点，最后形成凸包。 凸壳：凸包的一部分。 此算法主要分为两部分： 排序 扫描 # Part 3.3.1.1 排序 我们先选择一个 yyy 最小的点（如 yyy 相同选 xxx 最小），记为 p1p_1p1​。 剩下的点，按照极角的大小逆时针排序，记为 p2,p3,…,pmp_2,p_3,\\dots, p_mp2​,p3​,…,pm​。 # Part 3.3.1.2 扫描 （下列所说的左右等是指以上一条连线为铅垂线，新的连线偏移的方向） 刚开始，我们的点集是这样的： p1p_1p1​ 为起始点。 随后，p2p_2p2​ 准备入栈，由于栈元素很少，所以可以入栈。 再看 p3p_3p3​，因为 p3p_3p3​ 向左，符合凸包条件，入栈。 随后 p4p_4p4​ 也一切正常，依然向左，入栈。 p5p_5p5​ 依然向左，入栈。 到 p6p_6p6​ 时，我们发现了点问题，就是不再是向左了，而是向右了，所以我们此时要将 p5p_5p5​ 出栈，p6p_6p6​ 入栈。 入栈后，我们发现，相对于 p4p_4p4​，p6p_6p6​ 依然是向右的，所以我们还要把 p4p_4p4​ 出栈，p6p_6p6​ 入栈。 接下来 p7p_7p7​ 没有问题。 p8p_8p8​ 时，我们发现，也是向右的，所以将 p7p_7p7​ 出栈，p8p_8p8​ 入栈。 接下来 p9p_9p9​ 正常，入栈。 最后，我们再把最后一个点和第一个点连起来。 此时，我们的 Graham 算法的全过程就结束了。 时间复杂度为 O(nlog⁡n)O(n \\log n)O(nlogn)。 # Part 3.3.2 Andrew 算法 Graham 算法的一种进阶。 假设我们有这些点： 首先把所有点以横坐标为第一关键字，纵坐标为第二关键字排序。 相对于 Graham 算法来说，Andrew 算法排序更简单，按 x,yx, yx,y 坐标排序，时间复杂度也更低（一般的坐标系中排序方法）。 首先将 p1p_1p1​ 入栈。 然后也将 p2p_2p2​ 入栈，p2p_2p2​ 可能在，也可能不在，等着之后判断。 随后，发现 p3p_3p3​ 偏右，所以我们将 p2p_2p2​ 出栈。 发现 p4p_4p4​ 依然偏右，p3p_3p3​ 出栈，p4p_4p4​ 入栈。 p5p_5p5​ 向右，p4p_4p4​ 出栈，p5p_5p5​ 入栈。 p6p_6p6​ 向左，入栈。 p7p_7p7​ 向右，p6p_6p6​ 出栈，p7p_7p7​ 入栈。 p8p_8p8​ 向右，p7p_7p7​ 出栈，继续检查发现相对于 p5p_5p5​ p8p_8p8​ 仍然向右，p5p_5p5​ 出栈，p8p_8p8​ 入栈。 此时，我们发现，凸包空了一半。 所以我们需要再从排序末尾的点（也就是 p8p_8p8​）出发，按照一模一样的方式再算一遍就行了。 当然如果我们走过的点就不许要再走了（除了 p1p_1p1​）. 从 p8p_8p8​ 到 p7p_7p7​，向左，p7p_7p7​ 入栈。 p6p_6p6​ 向右，p7p_7p7​ 出栈，p6p_6p6​ 入栈。 p5p_5p5​ 向左，入栈。 p4p_4p4​ 向左，入栈。 p3p_3p3​ 向右，p4p_4p4​ 出栈，对于 p5p_5p5​ p3p_3p3​ 依然向右，p5p_5p5​ 出栈，p3p_3p3​ 入栈。 p2p_2p2​ 向右，p3p_3p3​ 出栈，p2p_2p2​ 入栈。 最后将 p2p_2p2​ 和 p1p_1p1​ 连起来。 至此，我们的 Andrew 算法就完成了！ 时间复杂度：O(nlog⁡n)O(n \\log n)O(nlogn) # Part 3.4 实战演练 # Part 3.4.1 P2742 [USACO5.1] 圈奶牛 Fencing the Cows /【模板】二维凸包 先拿模板题练练手。 题目简述：求一个二维凸包的周长。 拿 Graham 算法做即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define line cout &lt;&lt; endlusing namespace std;const int NR = 1e5 + 5;int n;double ans;struct point &#123; double x, y;&#125;;point p[NR], ps[NR];double dis (point pa, point pb) &#123; //求两点间距离 return sqrt ((pb.x - pa.x) * (pb.x - pa.x) + (pb.y - pa.y) * (pb.y - pa.y));&#125;double cp (point pa1, point pa2, point pb1, point pb2) &#123; //求叉积 return (pa2.x - pa1.x) * (pb2.y - pb1.y) - (pb2.x - pb1.x) * (pa2.y - pa1.y);&#125;bool cmp (point px, point py) &#123; //排序 double num = cp (p[1], px, p[1], py); if (num &gt; 0) return true; if (num == 0 &amp;&amp; dis (p[0], px) &lt; dis (p[0], py)) return true; return false;&#125;int main () &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; p[i].x &gt;&gt; p[i].y; if(i != 1 &amp;&amp; p[i].y &lt; p[1].y) &#123; //去重 swap (p[i].y, p[1].y); swap (p[i].x, p[1].x); &#125; &#125; sort (p + 2, p + n + 1, cmp); ps[1] = p[1]; //最低点是肯定在凸包里的 int h = 1; for (int i = 2; i &lt;= n; i++) &#123; while (h &gt; 1 &amp;&amp; cp (ps[h - 1], ps[h], ps[h], p[i]) &lt;= 0) &#123; //判断是向左还是向右，如果向右就出栈 h--; &#125; h++; ps[h] = p[i]; &#125; ps[h + 1] = p[1]; //最后一个点跟第一个点相连 for (int i = 1; i &lt;= h; i++) &#123; ans += dis (ps[i], ps[i + 1]); //累加 &#125; printf (&quot;%.2lf\\n&quot;, ans); return 0;&#125; # Part 3.4.2 UVA11626 Convex Hull 这题好像拿 Graham 会 TLE？拿 Andrew 罢，也是道模板题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;string&gt;#define line cout &lt;&lt; endlusing namespace std;const int NR = 1e5 + 5;const double eps = 1e-7;int n;struct point &#123; double x, y; point () &#123;&#125; point (double a, double b) : x (a), y (b) &#123;&#125; bool operator &lt; (const point &amp;b) const &#123; if (x &lt; b.x) return 1; if (x &gt; b.x) return 0; return y &lt; b.y; &#125; point operator - (const point &amp;b) &#123; return point (x - b.x, y - b.y); &#125;&#125;;point p[NR], sp[NR];int cmp (double x) &#123; if (fabs (x) &lt; eps) return 0; return x &gt; 0 ? 1 : -1;&#125;double dis (point a, point b) &#123; return sqrt ((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));&#125;double cp (point a, point b) &#123; return a.x * b.y - a.y * b.x;&#125;int Andrew () &#123; sort (p + 1, p + 1 + n); int len = 0; for (int i = 1; i &lt;= n; i++) &#123; while (len &gt; 1 &amp;&amp; cmp (cp (sp[len] - sp[len - 1], p[i] - sp[len - 1])) &lt; 0) len--; sp[++len] = p[i]; &#125; int k = len; for (int i = n - 1; i &gt;= 1; i--) &#123; while (len &gt; k &amp;&amp; cmp (cp (sp[len] - sp[len - 1], p[i] - sp[len - 1])) &lt; 0) len--; sp[++len] = p[i]; &#125; return len;&#125;int main () &#123; int t; cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; n; char c; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; p[i].x &gt;&gt; p[i].y &gt;&gt; c; int t = Andrew(); cout &lt;&lt; t - 1 &lt;&lt; endl; for (int i = 1; i &lt; t; i++) printf (&quot;%.0lf %.0lf\\n&quot;, sp[i].x, sp[i].y); &#125; return 0;&#125; The End…","categories":[{"name":"笔记","slug":"笔记","permalink":"https://www.tsd-blog.tk/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"计算几何","slug":"计算几何","permalink":"https://www.tsd-blog.tk/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"},{"name":"凸包","slug":"凸包","permalink":"https://www.tsd-blog.tk/tags/%E5%87%B8%E5%8C%85/"}]}],"categories":[{"name":"题解","slug":"题解","permalink":"https://www.tsd-blog.tk/categories/%E9%A2%98%E8%A7%A3/"},{"name":"笔记","slug":"笔记","permalink":"https://www.tsd-blog.tk/categories/%E7%AC%94%E8%AE%B0/"},{"name":"游记","slug":"游记","permalink":"https://www.tsd-blog.tk/categories/%E6%B8%B8%E8%AE%B0/"}],"tags":[{"name":"AtCoder","slug":"AtCoder","permalink":"https://www.tsd-blog.tk/tags/AtCoder/"},{"name":"ABC","slug":"ABC","permalink":"https://www.tsd-blog.tk/tags/ABC/"},{"name":"二分答案","slug":"二分答案","permalink":"https://www.tsd-blog.tk/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"},{"name":"二分搜索","slug":"二分搜索","permalink":"https://www.tsd-blog.tk/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"},{"name":"计算几何","slug":"计算几何","permalink":"https://www.tsd-blog.tk/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"},{"name":"2020","slug":"2020","permalink":"https://www.tsd-blog.tk/tags/2020/"},{"name":"CSp","slug":"CSp","permalink":"https://www.tsd-blog.tk/tags/CSp/"},{"name":"NOIp","slug":"NOIp","permalink":"https://www.tsd-blog.tk/tags/NOIp/"},{"name":"模拟","slug":"模拟","permalink":"https://www.tsd-blog.tk/tags/%E6%A8%A1%E6%8B%9F/"},{"name":"凸包","slug":"凸包","permalink":"https://www.tsd-blog.tk/tags/%E5%87%B8%E5%8C%85/"}]}